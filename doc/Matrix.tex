%===============================================================================
%
% LI GROUP LATEX TEMPLATE FOR ACS JOURNAL SUBMISSION
% Updated: Mar 17, 2014 by JW May
% Created: Oct 02, 2012 by JW May
%
%===============================================================================


% ******************************************************************************
%  IMPORTANT
% ******************************************************************************
%  Make sure you have the latest version of the `achemso` package when using
%  this manuscript template.  To update your version of the `achemso` package
%  execute the following commands in the terminal:
%      > sudo tlmgr update --self
%      > sudo tlmgr update achemso
%  These commands run the TeX Live package manager self-updater and package
%  updater.
% ******************************************************************************


%-------------------------------------------------------------------------------
% PREAMBLE AND DOCUMENT FORMATTING
%-------------------------------------------------------------------------------
% The documentclass options and setkeys command enable the printing of the
% entire author list for citations; this is especially useful for printing the
% entire Gaussian author list.
%
% For a list of journal types for the journal option below, see the table at
% the end of this document.
%-------------------------------------------------------------------------------
\documentclass[english,journal=jctcce,manuscript=article,etalmode=truncate,maxauthors=0]{article}


% PACKAGES
\usepackage{amsmath}             % for equation typesetting
\usepackage{amssymb}             % for equation typesetting
\usepackage{wasysym}             % for geometric shapes
\usepackage{color}               % for colored fonts
\usepackage{setspace}            % for 1.5 and double spacing
\usepackage{graphicx}            % main graphics package
\usepackage{wrapfig}             % allow text wrapping around figures
\usepackage[dvipsnames]{xcolor}  % for inserting colored text
%\usepackage{times}              % uncomment to use Times New Roman font
\usepackage[user=XXX]{trkchg}    % provides commands for tracking changes in the compiled document
\usepackage{array,booktabs}      % for formatting the journal option table at the end of this document
\usepackage[margin=0.5in]{geometry}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=c++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% ACHEMSO PACKAGE FORMATTING OPTIONS
%\SectionNumbersOff    % turn off section numbering
%\SectionsOff         % turn off section headers
%\AbstractOff         % turn off display of abstract

% CAPTION FORMATTING
\usepackage[font=footnotesize,labelfont=bf,labelsep=period,width=0.75\textwidth]{caption}   % format single-image captions and table titles
\usepackage[font=footnotesize,labelfont=bf,labelsep=period]{subcaption}                     % format subfigure captions
\DeclareCaptionSubType*[arabic]{figure}                                                     % use arabic numerals for subfigure captions (e.g., 1.1, 1.2, etc.)
\DeclareCaptionLabelFormat{subfiglabel}{Figure #2}                                          % append 'Figure' to subfigure captions (e.g., Figure 1.1, Figure 1.2, etc.)
\captionsetup[subfigure]{labelformat=subfiglabel,singlelinecheck=false}                     % format subfigure captions

% CROSS-REFERENCE FORMATTING
% For use with the cleveref package
% Define the format of Figure, Table, Equation, and Section cross-references in the text
\usepackage[capitalize]{cleveref}
\crefname{figure}{Fig.}{Figs.}
\Crefname{figure}{Figure}{Figures}
\crefname{table}{Tab.}{Tabs.}
\Crefname{table}{Table}{Tables}
\crefname{equation}{Eq.}{Eqs.}
\Crefname{equation}{Equation}{Equations}
\crefname{section}{Sec.}{Secs.}
\Crefname{section}{Section}{Sections}

% CUSTOM LI GROUP COMMANDS
%
% General / Formatting
\newcommand{\bd}[1]{\textbf{#1}} % bold text
\newcommand{\subsubsubsection}[1]{\vspace{5pt}\noindent{\underline{\emph{#1}}}\vspace{4pt}} % subsubsubsection command
%
% For quantum dot papers
\newcommand{\Mn}{Mn$^{2+}$}
\newcommand{\Co}{Co$^{2+}$}
\newcommand{\Zn}{Zn$^{2+}$}
\newcommand{\Cd}{Cd$^{2+}$}
\newcommand{\Se}{Se$^{2-}$}
\newcommand{\MLCT}{ML$_{\text{CB}}$CT}
\newcommand{\LMCT}{L$_{\text{VB}}$MCT}
\newcommand{\MnZnO}{Mn$^{2+}$:ZnO}
\newcommand{\CoZnO}{Co$^{2+}$:ZnO}
\newcommand{\MnCdSe}{Mn$^{2+}$:CdSe}
\newcommand{\CoCdSe}{Co$^{2+}$:CdSe}
\newcommand{\ecb}{$e_{\text{CB}}^{-}$}
\newcommand{\ecbp}{$e_\text{CB}^{-}$$^{\prime}$}
\newcommand{\hvb}{$h_{\text{VB}}^+$}
\newcommand{\sd}{$s$--$d$}
\newcommand{\pd}{$p$--$d$}
\newcommand{\spd}{$sp$--$d$}
\newcommand{\dqd}{d$_{\text{QD}}$}
%
% Chemistry shortcuts
\newcommand{\atom}[2]{#1$_{#2}$}                          % subscripted atom symbol
\newcommand{\term}[3]{$^{#1}$#2$_{#3}$}                   % term (level) symbol
%
% Mathematical Shortcuts
\newcommand{\pfrac}[2]{\frac{\partial #1}{\partial #2}}   % partial derivative
\newcommand{\difrac}[2]{\frac{d #1}{d #2}}                % derivative
\newcommand{\bpar}[1]{\left( #1 \right)}                  % big parentheses
\newcommand{\bbra}[1]{\left[ #1 \right]}                  % big brackets
\newcommand{\bbar}[1]{\left| #1 \right|}                  % big bars
\newcommand{\bra}[1]{\left\langle #1 \right\vert}         % bra
\newcommand{\ket}[1]{\left\vert #1 \right\rangle}         % ket
\newcommand{\inner}[2]{\left\langle #1 \left\vert\right. #2 \right\rangle}            % bracket
\newcommand{\innerop}[3]{\left\langle #1 \left\vert #2 \right\vert #3 \right\rangle}  % operator matrix element
\newcommand{\innersub}[4]{\langle \bd{#1}_{#2}, \bd{#3}_{#4} \rangle}                 % bracket with subscripts
\newcommand{\half}{\frac{1}{2}}                           % 1/2
\newcommand{\powfrac}[3]{\bpar{\frac{#1}{#2}}^{#3}}       % fraction raised to a power
\newcommand{\ii}{\infty}                                  % infinity symbol
\newcommand{\tquad}{\quad\quad\quad}                      % triple-quad 
\renewcommand{\Im}{\text{Im}}                             % imaginary symbol
\renewcommand{\Re}{\text{Re}}                             % real symbol
%-------------------------------------------------------------------------------
% Place any additional macros here.  Please use \newcommand* where
% possible, and avoid layout-changing macros.
%-------------------------------------------------------------------------------
\newcommand*\mycommand[1]{\texttt{\emph{#1}}}

%-------------------------------------------------------------------------------
% TITLE AND AUTHOR LIST
%-------------------------------------------------------------------------------
%
% The document title should be given as usual.  Some journals require
% a running title from the author: this should be supplied as an
% optional argument to \title.
%
% Each author should be given as a separate \author command.
%
% Corresponding authors should have an e-mail given after the author
% name as an \email command. Phone and fax numbers can be given
% using \phone and \fax, respectively; this information is optional.
%
% The affiliation of authors is given after the authors; each
% \affiliation command applies to all preceding authors not already
% assigned an affiliation.
%
% The affiliation takes an option argument for the short name.  This
% will typically be something like "University of Somewhere".
%
% The \altaffiliation macro should be used for new address, etc.
% On the other hand, \alsoaffiliation is used on a per author basis
% when authors are associated with multiple institutions.
%-------------------------------------------------------------------------------
%\title[ChronQ:Matrix Class]{A Guide to the Functionality of the Matrix Class in the Chronus Quantum Chemistry (ChronQ) Software Package}
%\author{David Williams-Young}
%\affiliation[University of Washington]
%{Department of Chemistry, University of Washington, Seattle, WA, 98195}
%\email{dbwy@u.washington.edu}

%-------------------------------------------------------------------------------
% ABBREVIATIONS AND KEYWORDS
%-------------------------------------------------------------------------------
% Some journals require a list of abbreviations or keywords to be
% supplied. These should be set up here, and will be printed after
% the title and author information, if needed.
%-------------------------------------------------------------------------------


%===============================================================================
%
% MAIN DOCUMENT BEGINS
%
%===============================================================================
\begin{document}


%-------------------------------------------------------------------------------
% INTRODUCTION
%-------------------------------------------------------------------------------
\section{Motivation}

The \texttt{Matrix} class in the \emph{Chronus Quantum Chemistry} (ChronQ) software package was made to hide the tedious nuances of matrix manipulation in \texttt{C++} behind a user-friendly, but highly efficient front end. In the end, developers of the ChronQ package are able to perform everyday matrix manipulations using a \texttt{MATLAB}-esque syntax and without having to worry about the internal storage, memory allocation / deallocation, etc. (unless they really want to). This document aims to supplement the in-code documentation of the \texttt{Matrix} class to better define the functionality and usage of \texttt{Matrix} objects in the ChronQ source code.

\section{Matrix Class Private Metadata}
The current list of the metadata that is contained in the \texttt{Matrix} object (1/27/2015):

\begin{table}[h!]
\begin{tabular}{| l | l | l |}
\hline
\textbf{Data Type} & \textbf{Variable} & \textbf{Description}\\
\hline
int   &    rows\_             & Number of rows (leading dimension) to be used by routines\\
  int   &    cols\_             & Number of columns (slowest running index) to be used by routies\\
  int   &    rows\_p\_           & Number of rows (leading dimension) upon allocation (permanent)\\
  int   &    cols\_p\_           & Number of columns (slowest running index) upon allocation (permanent)\\
  int   &    len\_              & Number of elements being stored in the matrix (length of data array)\\
  int   &    format\_           & Storage format\\
        &                       &   0:  Standard dense matrix (Column-Major)\\
        &                       &   1:  Packed lower triangle (Column-Major)\\
  int   &    size\_             & Size of the matrix object (all internal storage, buggy)\\
  int   &    haveEigen\_        & Level of eigensystem storage (compounds)\\
        &                       &   0:  No eigensystem is stored\\
        &                       &   1:  Eigenvalues are stored\\
        &                       &   2:  Right Eigenvectors are stored\\
        &                       &   3:  Left Eigenvectors are stored  (If applicable)\\
        &                       &   4:  Eigenvalues are broken into   (If applicable)\\
  bool  &    vectorized\_      & Boolean as to whether or not to treat the matrix as a vector\\
  char  &    *name\_ & Name of the Matrix Object\\
  char  &    trans\_            & Transpose flag (optionally conjugate). See LAPACK routines\\
  char  &    symm\_             & Symmetry of Matrix\\
        &                       &   G: Nonsymmetric\\
        &                       &   S: Symmetric (for real valued, defaults to 'H' for complex)\\
        &                       &   H: Hermetian (for complex values, defaults to 'S' for real)\\
  char  &    JOBVL\_            & Whether or not to compute Left Eigenvectors  (LAPACK)\\
  char  &    JOBVR\_            & Whether or not to compute Right Eigenvectors (LAPACK)\\
  T     &    *data\_            & Internal element storage\\
  T     &    *eigenvector\_     & Default eigenvector storage (will point to eigenvector\_r\_)\\
  T     &    *eigenvector\_r\_   & Default right eigenvector storage\\
  T     &    *eigenvector\_l\_   & Default left eigenvector storage (will point to eigenvector\_r\_ for 'S' and 'H')\\
  T     &    *eigenvalue\_      & Detault eigenvalue storage (will point to eigenvalue\_re\_ for double)\\
  double&    *eigenvalue\_re\_   & Real part of the eigenvalue vector\\
  double&    *eigenvalue\_im\_   & Imag part of the eigenvalue vector\\
  dcomplex&  *eigenvalue\_z\_    & Complex cast of the eigenvalue vector\\
\hline
& &T=double/dcomplex \\
\hline
\end{tabular}
\end{table}

\section{Creating A Matrix Object}
The \texttt{Matrix} class is a \texttt{C++ template} class that is currently implemented to manipulate \texttt{double} and \texttt{dcomplex} (double precision complex) matrices. It is the convention in ChronQ to create a pointer to a \texttt{Matrix} object, and then allocate it, as opposed to creating the object itself. This is because it is faster to pass a pointer to an object to a function than the object itself (which is the \texttt{C/C++} standard). Due to the large volume of matrix object used in ChronQ, the use of pointers drastically improves the performance. To allocate a \texttt{Matrix} object, one must invoke the constructor
\newpage
\begin{lstlisting}
int N = 2;
Matrix<double>    *A = new Matrix<double>(N,N);      // Allocates a 2x2 double precision matrix object
Matrix<dcomplex>*A = new Matrix<dcomplex>(N,N); // Allocates a 2x2 double precision complex matrix object
\end{lstlisting}
There is no ``default" constructor for the \texttt{Matrix} class (no constructor without arguements), so the above syntax is the most bare-bones way to allocate a \texttt{Matrix} object. In general, a \texttt{Matrix} object may be allocated as
\begin{lstlisting}
// Allocates a 2x2 double precision matrix object in full storage named "A"
Matrix<double>    *A = new Matrix<double>(N,N,"A","STD");
\end{lstlisting}
The two calls above reference the same constructor. The difference is that the constructor has been set to automatically set (by default) the name of the \texttt{Matrix} object to ``\texttt{NO NAME}" and have full storage (the ``\texttt{STD}" flag), i.e. there will be $N^2$ double prevision elements allocated. Currently, the only other implemented storage scheme is lower triangular (denoted ``\texttt{LT}"), although much of the mathematical functionality is not implemented for this scheme. This scheme allocates $N(N+1)/2$ double precision elements. If using the lower triangle storage scheme, one must use the \texttt{unpack} function to expand to full storage to perform much of the mathematical manipulation (and optionally \texttt{pack} to place it back into lower triangular storage). The source code for the constructors can be found in \texttt{matrix\_constructor.cpp}

\section{Accessing and Modifying Private Data of a Matrix Object}
All of the internal storage of the \texttt{Matrix} object is \emph{private}. As a result, we have adopted the traditional ``getters and setters" model of accessing and modifying the private internal storage, i.e. we have functions that bridge the gap between public access and private storage. The current list of getters and setters in the \texttt{Matrix} class (1/27/2015) is as follows
\begin{table}[h!]
\begin{tabular}{| l | l | l |}
\hline
\multicolumn{3}{|c|}{\textbf{Setters}}\\
\hline
\hline
\textbf{Return Type} & \textbf{Name} & \textbf{Description} \\
\hline
  void&cpyData(U*) &Copy contents of an array to internal storage\\
  void&setName(char*) &Set the name of the matrix object\\
  void&setSymm(char) &Set the symmetry of the matrix object\\
  void& setDag(U*) &Set the diagonal elements of the matrix to array\\
\hline
\hline
\multicolumn{3}{|c|}{\textbf{Getters}}\\
\hline
\hline
\textbf{Return Type} & \textbf{Name} & \textbf{Description} \\
\hline
  int &len() &Return the number of elements stored for matrix\\
  int &rows()& Return the number of rows being used in current treatment\\
  int &cols()& Return the number of cols being used in current treatment\\
  char& symm()& Return the symmetry currently being used\\
  T   &*data()& Return the internal storage array\\
  int & size()& Return the size of the matrix object (buggy)\\
  int &format()& Return the storage format\\
  T& *eigenvector()& Return the defualt eigenvector array (see \texttt{diag})\\
  T& *eigenvector\_r()& Return the right eigenvector array \\
  T& *eigenvector\_l()& Return the left eigenvector array  \\
  T&    *eigenvalue()& Return the default eigenvalue array (see \texttt{diag})\\
  double&  *eigenvalue\_re()& Return the real part of the eigenvalues  \\
  double&  *eigenvalue\_im()& Return the imag part of the eigenvalues  \\
  dcomplex &*eigenvalue\_z()& Return the eigenvalues in complex format\\
\hline
\end{tabular}
\end{table}
\newpage
Usage of the setters are as follows
\begin{lstlisting}
// Allocate Matrices
Matrix<double>    *A_double  = new Matrix<double>(N,N); 
Matrix<dcomplex>*A_complex = new Matrix<dcomplex>(N,N);

// Name Matrices (This can be done with the constructor as well)
A_double->setName("A Double");       // Name A_double as "A Double"
A_complex->setName("A Complex"); // Name A_complex as "A Complex"

// Set the symmetry to be used by the LAPACK routines
A_double->setSymm('S');     // Change symmetry from 'G' to 'S' (Symmetric Matrix)
A_complex->setSymm('H'); // Change symmetry from 'G' to 'H' (Hermitian Matrix)

// Set integral element storage
double *x_d = new double[N];
double *y_d = new double[N*N];
dcomplex *x_c = new dcomplex[N};
dcomplex *y_c = new dcomplex[N*N};
// Populate the arrays
A_double->cpyData(y_d);     // Copy the contents of y_d to the matrix elements of A_double
A_complex->cpyData(y_c); // Copy the contents of y_c to the matrix elements of A_complex
A_complex->cpyData(y_d); // Copy the contents of y_d to the real part of the matrix elements of A_complex
A_double->setDag(x_d);      // Copy the contents of x_d to the diagonal matrix elements of A_double
A_complex->setDag(x_c);     // Copy the contents of x_c to the diagonal matrix elements of A_complex
A_complex->setDag(x_d);     // Copy the contents of x_d to the real part of the diagonal matrix elements of A_complex
\end{lstlisting}

\section{Mathematical Manipulations using the Matrix Class}
The most useful feature of the \texttt{Matrix} class is its ability to perform complex mathematical manipulations in a very user-friendly interface. The mathematical capabilities can best be broken into two categories: operator overload and mathematical drivers.
\subsection{Operator overload and structs in the Matrix Class}
The use of overloaded operators in the \texttt{Matrix} class is heavily dependent on the use of \texttt{struct}. The current list of implemented \texttt{struct} variables (01/27/2015) is as follows
\begin{table}[h!]
\begin{tabular}{| l | l | l |}
\hline
\texttt{struct} \textbf{Name} & \textbf{Members} & \textbf{Description}\\
\hline
Prod& const Matrix *a, const Matrix *b& Struct for multiplication. Used by the product operator to facilitate $AB$\\
 Sum& const Matrix *a, const Matrix *b& Struct for summation. Used by addition operator to facilitate $A+B$\\
Diff& const Matrix *a, const Matrix *b& Struct for subtraction Used by subtraction operator to facilitate $A-B$\\
 TTN& const Matrix *a, const Matrix *x& Struct for (XT)AX transformation. Used by \texttt{transTN} to do $X^\dagger A X$\\
 TNT& const Matrix *a, const Matrix *x& Struct for XA(XT) transformation. Used by \texttt{transNT} to do $X A X^\dagger$\\
 PWR& const Matrix *a, const T      *x& Struct for Matrix exponential. Used by caret operator to perform $A^x$\\
 EXP& const Matrix *a                 & Struct for exp(A). Used by \texttt{exp} function to perform $e^A$\\
\hline
\end{tabular}
\end{table}
\newpage
The current list (1/27/2015) of overloaded operators in the \texttt{Matrix} class is as follows
\begin{table}[h!]
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Return Type} & \textbf{Operator} & \textbf{Arguments} & \textbf{Description}\\
\hline
void &\texttt{operator=}&const double*        & Copy matrix from double array \\
void &\texttt{operator=}&const dcomplex*      & Copy matrix from complex array\\
void &\texttt{operator=}&const EXP\&          & Assignment operator for exp(A) (Performs arithmetic)\\
void &\texttt{operator=}&const Matrix*        & Copy matrix from matrix (of the same type)\\
void &\texttt{operator=}&const Sum\&          & Assignment operator for summation (Performs arithmetic)\\
void &\texttt{operator=}&const Diff\&         & Assignment operator for subtraction (Performs arithmetic)\\
void &\texttt{operator=}&const Prod\&         & Assignment operator for multiplication (Performs arithmetic)\\
void &\texttt{operator=}&const TTN\&          & Assignment operator for $X^\dagger AX$ transformation (Performs arithmetic)\\
void &\texttt{operator=}&const TNT\&          & Assignment operator for $X AX^\dagger$ transformation (Performs arithmetic)\\
void &\texttt{operator=}&const PWR\&          & Assignment operator for $A^x$ (Performs arithmetic)\\
Sum  &\texttt{operator+}&const Matrix\&       & Summation operator. Returns \texttt{struct} for associated \texttt{operator=}\\
Diff &\texttt{operator-}&const Matrix\&       & Subtraction operator. Returns \texttt{struct} for associated \texttt{operator=}\\
Prod &\texttt{operator*}&const Matrix\&       & Multiplication operator. Returns \texttt{struct} for associated \texttt{operator=}\\
PWR  &\texttt{operator\^{}}&const T\&         & Exponentiation operator. Returns \texttt{struct} for associated \texttt{operator=}\\
void &\texttt{operator+=}&const Matrix*       & Increment operator. Adds contents of \texttt{Matrix} object to \texttt{this} \\
void &\texttt{operator-=}&const Matrix*       & Decrement operator. Subtracts contents of \texttt{Matrix} object to \texttt{this} \\
\hline
\end{tabular}
\end{table}

with syntax (extends to double)
\begin{lstlisting}
// Allocate Matrices
Matrix<dcomplex>    *A_complex  = new Matrix<dcomplex>(N,N); 
Matrix<dcomplex>    *A_cpy      = new Matrix<dcomplex>(N,N);
Matrix<dcomplex>    *B          = new Matrix<dcomplex>(N,N);
// Set integral element storage
double *x_d    = new double[N*N];
dcomplex *x_c = new dcomplex[N*N];
// Populate the arrays

// Copy Operators
(*A_complex) = x_c; // Copy contents of x_c into the matrix elements of A_complex (same function as cpyData())
(*A_complex) = x_d; // Copy contents of x_d into the real part of A_complex (same function as cpyData())
(*A_cpy)       = A_complex; // Copy A_complex into A_cpy

// Mathematical Manipulation Operators
(*B) =   (*A_complex) + (*A_cpy); // B is the sum of A_complex and A_cpy
(*B) =   (*A_complex) - (*A_cpy); // B is the difference of A_complex and A_cpy
(*B) =   (*A_complex) * (*A_cpy); // B is the product of A_complex and A_cpy
(*B) =   (*A_complex) ^ 0.5; // B is the square root of A_complex
(*B) += (*A_complex); // B is incremented by the elements of A_complex
(*B) -= (*A_complex); // B is decremented by the elements of A_complex
\end{lstlisting}

\subsection{Notes on Operator Overload in the Matrix Class}
\subsubsection{Arithmetic Conventions}
It is the convention in the \texttt{Matrix} class that the actual mathematical manipulation is performed by the corresponding assignment operator, not the arithmetic operator itself. For example, when performing a matrix product $AB$, \texttt{operator*} returns a Prod \texttt{struct} that is passed to the \texttt{operator=} that takes the Prod \texttt{struct} as a parameter. Once this \texttt{struct} has been passed into the assignment operator, a number of checks are performed on the \texttt{Matrix} object to be assigned (is it of the correct dimension, etc) and faults are fixed. Once the \texttt{Matrix} object has been made to be compatible, the necessary arithmetic is performed and the result is stored in said \texttt{Matrix} object. While these checks are performed, it is good programming practice to ensure that the matrices are compatible before performing arithmetic as the checking and fixing routines may do something stupid.

\subsubsection{Matrix Product Notes/Dependencies}
With respect to matrix products, the \texttt{Matrix} class acts as a smart wrapper for the BLAS routines \texttt{DGEMM, DSYMM, ZGEMM, ZSYMM, ZHEMM}. The appropriate routine is called based on the \texttt{Matrix} type and symmetry. As a result, the BLAS and LAPACK libraries must be linked at compile time (usually a \texttt{-llapack -lblas} linker line, or where ever your architecture optimized BLAS and LAPACK libraries are located). If using the Portland Group suite (\texttt{pgcpp, pgcc, pgfortran}, etc) of compilers, you must add \texttt{-pgf77libs} at linking.
\end{document}


























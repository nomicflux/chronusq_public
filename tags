!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AOCartesian	include/basisset.h	/^struct AOCartesian{$/;"	s	namespace:ChronusQ
AOIntegrals	include/aointegrals.h	/^  AOIntegrals(){;};$/;"	f	class:ChronusQ::AOIntegrals
AOIntegrals	include/aointegrals.h	/^class AOIntegrals{$/;"	c	namespace:ChronusQ
Atoms	include/atoms.h	/^struct Atoms { $/;"	s	namespace:ChronusQ
BasisPair	include/basisset.h	/^struct BasisPair{$/;"	s	namespace:ChronusQ
BasisSet	include/basisset.h	/^class BasisSet{ $/;"	c	namespace:ChronusQ
BasisSet	src/basisset/basisset.cpp	/^BasisSet::BasisSet(int nBasis, int nShell) {$/;"	f	class:BasisSet
CErr	src/cerr/cerr.cpp	/^void CErr(int msg) {$/;"	f
CPY	src/matrix/double/diag.cpp	/^double *CPY,*WORK$/;"	v
CShell	src/basisset/basisset_libint.cpp	/^typedef ChronusQ::Shell CShell;$/;"	t	file:
ChronusQ	include/aointegrals.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/atoms.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/basisset.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/cerr.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/classtools.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/controls.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/fileio.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/matrix.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/memory.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/mointegrals.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/molecule.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/sdresponse.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/singleslater.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/tools.h	/^namespace ChronusQ {$/;"	n
ChronusQ	include/workers.h	/^namespace ChronusQ {$/;"	n
ChronusQ	src/classtools/classtools.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/complex/matrix_constructor_complex.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/complex/matrix_io_complex.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/complex/matrix_miscmath_complex.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/complex/matrix_miscop_complex.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/complex/matrix_overload_complex.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/complex/matrix_setters_complex.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/complex/matrixop_complex.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/double/matrix_constructor_double.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/double/matrix_io_double.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/double/matrix_miscmath_double.cpp	/^namespace ChronusQ{$/;"	n	file:
ChronusQ	src/matrix/double/matrix_miscop_double.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/double/matrix_overload_double.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/matrix/double/matrix_setters_double.cpp	/^namespace ChronusQ {$/;"	n	file:
ChronusQ	src/tools/tools.cpp	/^namespace ChronusQ { $/;"	n	file:
Controls	include/controls.h	/^  Controls(){;};$/;"	f	class:ChronusQ::Controls
Controls	include/controls.h	/^class Controls {$/;"	c	namespace:ChronusQ
DFT	include/controls.h	/^  bool  	DFT;            \/\/ use density functional theory$/;"	m	class:ChronusQ::Controls
Diff	include/matrix.h	/^  struct    Diff{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Subtraction$/;"	s	class:ChronusQ::Matrix
EXP	include/matrix.h	/^  struct     EXP{ const Matrix *a;};                   \/\/ Struct for exp(A)$/;"	s	class:ChronusQ::Matrix
Factorial	include/global.h	/^static double Factorial[8] ={$/;"	v
FileIO	include/fileio.h	/^class FileIO {$/;"	c	namespace:ChronusQ
FileIO	src/fileio/fileio.cpp	/^FileIO::FileIO(char *nm_input) {$/;"	f	class:FileIO
FmT	include/aointegrals.h	/^  double FmT[MAXANGULARMOMENTUM][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
FmTTable_	include/aointegrals.h	/^  double	**FmTTable_;$/;"	m	class:ChronusQ::AOIntegrals
FmU	include/aointegrals.h	/^  double FmU[10][MAXCONTRACTION][MAXCONTRACTION][MAXATOMS];   \/\/ [ss]^m = FmU * vK$/;"	m	struct:ChronusQ::PairConstants
GlobalMPI	include/global.h	/^struct GlobalMPI {$/;"	s
HF	include/controls.h	/^  bool  	HF;             \/\/ use Hartree-Fock$/;"	m	class:ChronusQ::Controls
HashAtom	src/tools/tools.cpp	/^int HashAtom(char *symbol, int massNumber) { $/;"	f	namespace:ChronusQ
HashIAO	src/tools/tools.cpp	/^int HashIAO(int L,int *l) {$/;"	f	namespace:ChronusQ
HashL	src/tools/tools.cpp	/^int HashL(char *symbol) {$/;"	f	namespace:ChronusQ
HashNAOs	src/tools/tools.cpp	/^int HashNAOs(char *symbol) { $/;"	f	namespace:ChronusQ
HashNAOs	src/tools/tools.cpp	/^int HashNAOs(int L) { $/;"	f	namespace:ChronusQ
INCLUDED_AOINTEGRAL	include/aointegrals.h	27;"	d
INCLUDED_ATOMS	include/atoms.h	27;"	d
INCLUDED_BASISSET	include/basisset.h	27;"	d
INCLUDED_CLASSTOOLS	include/classtools.h	27;"	d
INCLUDED_CONTROLS	include/controls.h	27;"	d
INCLUDED_FILEIO	include/fileio.h	27;"	d
INCLUDED_GLOBAL	include/global.h	27;"	d
INCLUDED_MATRIX	include/matrix.h	27;"	d
INCLUDED_MEMORY	include/memory.h	27;"	d
INCLUDED_MOINTEGRAL	include/mointegrals.h	27;"	d
INCLUDED_MOLECULES	include/molecule.h	27;"	d
INCLUDED_SDRESPONSE	include/sdresponse.h	27;"	d
INCLUDED_SINGLESLATER	include/singleslater.h	27;"	d
INCLUDED_TOOLS	include/tools.h	27;"	d
INCLUDED_WORKERS	include/workers.h	27;"	d
JOBVL_	include/matrix.h	/^  char      JOBVL_;            \/\/ Whether or not to compute Left Eigenvectors  (LAPACK)$/;"	m	class:ChronusQ::Matrix
JOBVR_	include/matrix.h	/^  char      JOBVR_;            \/\/ Whether or not to compute Right Eigenvectors (LAPACK)$/;"	m	class:ChronusQ::Matrix
KAB	include/basisset.h	/^  double  KAB[MAXCONTRACTION][MAXCONTRACTION];		\/\/ KAB used to compute the [ss|ss] integral$/;"	m	struct:ChronusQ::ShellPair
L	include/aointegrals.h	/^  int L[2];        \/\/total angular momentum of each AO$/;"	m	struct:ChronusQ::PairConstants
L	include/basisset.h	/^  int     L;                     \/\/ angular momentum  -  0 , 1 , 2,  3 , 4$/;"	m	struct:ChronusQ::Shell
L	include/basisset.h	/^  int     L[2];                 \/\/ angular momenta of the first and second shells$/;"	m	struct:ChronusQ::BasisPair
L	include/basisset.h	/^  int     L[2];                 \/\/ angular momenta of the first and second shells$/;"	m	struct:ChronusQ::ShellPair
LIShell	src/basisset/basisset_libint.cpp	/^typedef libint2::Shell LIShell;$/;"	t	file:
LTotal	include/basisset.h	/^  int	  LTotal;		\/\/ total angular momenta of the shell pair$/;"	m	struct:ChronusQ::ShellPair
LWORK	src/matrix/double/diag.cpp	/^int LWORK;$/;"	v
MAXANGULARMOMENTUM	include/global.h	30;"	d
MAXATOMS	include/global.h	32;"	d
MAXBLOCK	include/fileio.h	28;"	d
MAXCONTRACTION	include/global.h	31;"	d
MAXNAMELEN	include/global.h	29;"	d
MOIntegrals	include/mointegrals.h	/^  MOIntegrals(){;};$/;"	f	class:ChronusQ::MOIntegrals
MOIntegrals	include/mointegrals.h	/^class MOIntegrals{$/;"	c	namespace:ChronusQ
Math	include/global.h	/^struct Math {$/;"	s
Matrix	include/matrix.h	/^class Matrix {$/;"	c	namespace:ChronusQ
Matrix	src/matrix/complex/matrix_constructor_complex.cpp	/^Matrix<dcomplex>::Matrix(int rows, int cols, char *nm, char *format) {$/;"	f	class:ChronusQ::Matrix
Matrix	src/matrix/double/matrix_constructor_double.cpp	/^Matrix<double>::Matrix(int rows, int cols, char *nm, char *format) {$/;"	f	class:ChronusQ::Matrix
MaxFmTPt	include/aointegrals.h	37;"	d
MaxTotalL	include/aointegrals.h	38;"	d
Memory	include/memory.h	/^class Memory {$/;"	c	namespace:ChronusQ
Memory	src/memory/memory.cpp	/^Memory::Memory(long n, char *unit, ostream output) {$/;"	f	class:Memory
MolecularConstants	include/aointegrals.h	/^struct MolecularConstants{$/;"	s	namespace:ChronusQ
Molecule	include/molecule.h	/^  Molecule(int nAtoms=0,FileIO *fileio=NULL){ if(nAtoms>0) iniMolecule(nAtoms,fileio);};$/;"	f	class:ChronusQ::Molecule
Molecule	include/molecule.h	/^class Molecule {$/;"	c	namespace:ChronusQ
OneEDriver	src/aointegrals/aointegrals_builders.cpp	/^void AOIntegrals::OneEDriver(OneBodyEngine::integral_type iType) {$/;"	f	class:AOIntegrals
PWR	include/matrix.h	/^  struct     PWR{ const Matrix *a; const T *x;};  \/\/ Struct for A^x$/;"	s	class:ChronusQ::Matrix
PairConstants	include/aointegrals.h	/^struct PairConstants{$/;"	s	namespace:ChronusQ
Phys	include/global.h	/^struct Phys {$/;"	s
Product	include/matrix.h	/^  struct Product{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Multiplication$/;"	s	class:ChronusQ::Matrix
QuartetConstants	include/aointegrals.h	/^struct QuartetConstants{$/;"	s	namespace:ChronusQ
R2Index_	include/aointegrals.h	/^  int       **R2Index_;$/;"	m	class:ChronusQ::AOIntegrals
R2Index_	include/sdresponse.h	/^  int       **R2Index_;$/;"	m	class:ChronusQ::SDResponse
R2Index_	include/singleslater.h	/^  int    **R2Index_;$/;"	m	class:ChronusQ::SingleSlater
RHF	include/singleslater.h	/^  inline int RHF()    { return this->RHF_; };$/;"	f	class:ChronusQ::SingleSlater
RHF_	include/singleslater.h	/^  int      RHF_;$/;"	m	class:ChronusQ::SingleSlater
SCF	src/singleslater/scf.cpp	/^void SingleSlater::SCF(){$/;"	f	class:SingleSlater
SDResponse	include/sdresponse.h	/^  SDResponse(){;};$/;"	f	class:ChronusQ::SDResponse
SDResponse	include/sdresponse.h	/^class SDResponse {$/;"	c	namespace:ChronusQ
SP	include/basisset.h	/^  bool	  SP;			 \/\/ is this part of an SP shell?$/;"	m	struct:ChronusQ::Shell
Sa0Par	include/aointegrals.h	/^  double Sa0Par[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
Shell	include/basisset.h	/^struct Shell{$/;"	s	namespace:ChronusQ
ShellPair	include/basisset.h	/^struct ShellPair{$/;"	s	namespace:ChronusQ
SingleSlater	include/singleslater.h	/^  SingleSlater(){;};$/;"	f	class:ChronusQ::SingleSlater
SingleSlater	include/singleslater.h	/^class SingleSlater {$/;"	c	namespace:ChronusQ
Sum	include/matrix.h	/^  struct     Sum{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Addition$/;"	s	class:ChronusQ::Matrix
TNT	include/matrix.h	/^  struct     TNT{ const Matrix *a; const Matrix *x;};  \/\/ Struct for XA(XT) transform$/;"	s	class:ChronusQ::Matrix
TTN	include/matrix.h	/^  struct     TTN{ const Matrix *a; const Matrix *x;};  \/\/ Struct for (XT)AX transform$/;"	s	class:ChronusQ::Matrix
Ta0Par3	include/aointegrals.h	/^  double Ta0Par3[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
TabPar1	include/aointegrals.h	/^  double TabPar1[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
TabPar2	include/aointegrals.h	/^  double TabPar2[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
TabPar3	include/aointegrals.h	/^  double TabPar3[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
UAB	include/basisset.h	/^  double  UAB[MAXCONTRACTION][MAXCONTRACTION];		\/\/ KAB used to compute the [ss|ss] integral$/;"	m	struct:ChronusQ::ShellPair
UPLO	src/matrix/double/diag.cpp	/^char UPLO = 'L';$/;"	v
a	include/matrix.h	/^  struct     EXP{ const Matrix *a;};                   \/\/ Struct for exp(A)$/;"	m	struct:ChronusQ::Matrix::EXP
a	include/matrix.h	/^  struct     PWR{ const Matrix *a; const T *x;};  \/\/ Struct for A^x$/;"	m	struct:ChronusQ::Matrix::PWR
a	include/matrix.h	/^  struct     Sum{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Addition$/;"	m	struct:ChronusQ::Matrix::Sum
a	include/matrix.h	/^  struct     TNT{ const Matrix *a; const Matrix *x;};  \/\/ Struct for XA(XT) transform$/;"	m	struct:ChronusQ::Matrix::TNT
a	include/matrix.h	/^  struct     TTN{ const Matrix *a; const Matrix *x;};  \/\/ Struct for (XT)AX transform$/;"	m	struct:ChronusQ::Matrix::TTN
a	include/matrix.h	/^  struct    Diff{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Subtraction$/;"	m	struct:ChronusQ::Matrix::Diff
a	include/matrix.h	/^  struct Product{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Multiplication$/;"	m	struct:ChronusQ::Matrix::Product
a000Par1	include/aointegrals.h	/^  double a000Par1[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
a000Par2	include/aointegrals.h	/^  double a000Par2[MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
a0c0Par1	include/aointegrals.h	/^  double a0c0Par1[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
a0c0Par2	include/aointegrals.h	/^  double a0c0Par2[MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
a0c0Par3	include/aointegrals.h	/^  double a0c0Par3[MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
abIndex_	include/mointegrals.h	/^  int       **abIndex_;$/;"	m	class:ChronusQ::MOIntegrals
abcd_	include/mointegrals.h	/^  ChronusQ::Matrix<double>    *abcd_;$/;"	m	class:ChronusQ::MOIntegrals
add	src/matrix/complex/matrix_miscmath_complex.cpp	/^template<> void Matrix<dcomplex>::add(const Matrix *a, const Matrix *b) {$/;"	f	class:ChronusQ::Matrix
add	src/matrix/double/matrix_miscmath_double.cpp	/^template<> void Matrix<double>::add(const Matrix *a, const Matrix *b) {$/;"	f	class:ChronusQ::Matrix
adjoint	include/matrix.h	/^  inline void adjoint(){$/;"	f	class:ChronusQ::Matrix
adjointHard	src/matrix/complex/matrix_miscmath_complex.cpp	/^void Matrix<dcomplex>::adjointHard(){$/;"	f	class:ChronusQ::Matrix
adjointHard	src/matrix/double/matrix_miscmath_double.cpp	/^void Matrix<double>::adjointHard(){ this->transposeHard();};$/;"	f	class:ChronusQ::Matrix
allocEigScr	src/matrix/complex/matrix_miscop_complex.cpp	/^template<>  dcomplex** Matrix<dcomplex>::allocEigScr(bool doGEP, int &LWORK, Matrix *B){$/;"	f	class:ChronusQ::Matrix
allocEigScr	src/matrix/double/matrix_miscop_double.cpp	/^template<>  double** Matrix<double>::allocEigScr(bool doGEP, int &LWORK, Matrix *B){$/;"	f	class:ChronusQ::Matrix
allocEigen	src/matrix/complex/matrix_miscop_complex.cpp	/^template<> void Matrix<dcomplex>::allocEigen(){$/;"	f	class:ChronusQ::Matrix
allocEigen	src/matrix/double/cleaneigen.cpp	/^void Matrix<double>::allocEigen(){$/;"	f	class:Matrix
allocEigen	src/matrix/double/matrix_miscop_double.cpp	/^template<> void Matrix<double>::allocEigen(){$/;"	f	class:ChronusQ::Matrix
allocScratch	src/matrix/double/cleaneigen.cpp	/^double *Matrix<double>::allocScratch(){$/;"	f	class:Matrix
ao	include/basisset.h	/^  AOCartesian *ao;             \/\/ array of ao's$/;"	m	class:ChronusQ::BasisSet
aoIndex	include/aointegrals.h	/^  int aoIndex[2];  \/\/location of PGTO in ao[]$/;"	m	struct:ChronusQ::PairConstants
aoIndex	include/basisset.h	/^  int     aoIndex;               \/\/ the starting index of the ao's in the shell in the ao[] array $/;"	m	struct:ChronusQ::Shell
aoIndex	include/basisset.h	/^  int     aoIndex[2];		\/\/ starting indeices of AOs in the first and second shells$/;"	m	struct:ChronusQ::ShellPair
aoIndex	include/basisset.h	/^  int     aoIndex[2];$/;"	m	struct:ChronusQ::BasisPair
aoPairIndex	include/basisset.h	/^  int     aoPairIndex[250][2];  \/\/ the indices of the ao pair in the ao[] array$/;"	m	struct:ChronusQ::ShellPair
aointegrals_	include/mointegrals.h	/^  ChronusQ::AOIntegrals   *aointegrals_;$/;"	m	class:ChronusQ::MOIntegrals
aointegrals_	include/singleslater.h	/^  ChronusQ::AOIntegrals   *aointegrals_;$/;"	m	class:ChronusQ::SingleSlater
atlas	src/atlas/atlas.cpp	/^int ChronusQ::atlas(int argc, char *argv[], GlobalMPI *globalMPI) {$/;"	f	class:ChronusQ
atom	include/atoms.h	/^static struct Atoms atom[344] = { $/;"	m	namespace:ChronusQ	typeref:struct:ChronusQ::Atoms
atomZ	include/aointegrals.h	/^  int atomZ[MAXATOMS];$/;"	m	struct:ChronusQ::MolecularConstants
atomicNumber	include/atoms.h	/^  int    atomicNumber; $/;"	m	struct:ChronusQ::Atoms
b	include/matrix.h	/^  struct     Sum{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Addition$/;"	m	struct:ChronusQ::Matrix::Sum
b	include/matrix.h	/^  struct    Diff{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Subtraction$/;"	m	struct:ChronusQ::Matrix::Diff
b	include/matrix.h	/^  struct Product{ const Matrix *a; const Matrix *b;};  \/\/ Struct for Multiplication$/;"	m	struct:ChronusQ::Matrix::Product
bannerEnd	include/global.h	/^const char bannerEnd[100]="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";$/;"	v
bannerMid	include/global.h	/^const char bannerMid[100]="--------------------------------------------------------------------------------";$/;"	v
bannerTop	include/global.h	/^const char bannerTop[100]="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";$/;"	v
basisSet_	include/aointegrals.h	/^  BasisSet     	*basisSet_;$/;"	m	class:ChronusQ::AOIntegrals
basisSet_	include/mointegrals.h	/^  ChronusQ::BasisSet     	*basisSet_;$/;"	m	class:ChronusQ::MOIntegrals
basisSet_	include/sdresponse.h	/^  ChronusQ::BasisSet     	*basisSet_;$/;"	m	class:ChronusQ::SDResponse
basisset_	include/singleslater.h	/^  ChronusQ::BasisSet     	*basisset_;$/;"	m	class:ChronusQ::SingleSlater
bin	include/fileio.h	/^  fstream bin;                   \/\/ file handler of the binary file$/;"	m	class:ChronusQ::FileIO
block	include/fileio.h	/^  long  block[MAXBLOCK];         \/\/ block pointers$/;"	m	class:ChronusQ::FileIO
blockBasisSet	include/global.h	/^enum {blockControlFlags,blockMolecule,blockBasisSet, \/\/ 1,2,3$/;"	e	enum:__anon1
blockControlFlags	include/global.h	/^enum {blockControlFlags,blockMolecule,blockBasisSet, \/\/ 1,2,3$/;"	e	enum:__anon1
blockIntegrals	include/global.h	/^      blockSingleSlater,blockIntegrals};  \/\/ 4,5,6$/;"	e	enum:__anon1
blockMolecule	include/global.h	/^enum {blockControlFlags,blockMolecule,blockBasisSet, \/\/ 1,2,3$/;"	e	enum:__anon1
blockSingleSlater	include/global.h	/^      blockSingleSlater,blockIntegrals};  \/\/ 4,5,6$/;"	e	enum:__anon1
bohr	include/global.h	/^  double bohr;$/;"	m	struct:Phys
cart	include/aointegrals.h	/^  double cart[3][MAXATOMS];$/;"	m	struct:ChronusQ::MolecularConstants
cart	include/molecule.h	/^  inline Matrix<double> *cart() {return this->cart_;}$/;"	f	class:ChronusQ::Molecule
cart_	include/molecule.h	/^  Matrix<double>  *cart_;        \/\/ cartesian coordinates$/;"	m	class:ChronusQ::Molecule
center	include/basisset.h	/^  int     center;                \/\/ index of the atom to which the shell belongs$/;"	m	struct:ChronusQ::Shell
center	include/basisset.h	/^  int     center[2];		\/\/ indices of the atom where the first and second shells are centered$/;"	m	struct:ChronusQ::ShellPair
centerA	include/basisset.h	/^  double  centerA[3];		\/\/ x,y,z coordinate of center A$/;"	m	struct:ChronusQ::ShellPair
centerB	include/basisset.h	/^  double  centerB[3];		\/\/ x,y,z coordinate of center B$/;"	m	struct:ChronusQ::ShellPair
centerIndex	include/basisset.h	/^  int     centerIndex[2];	\/\/ indices of the atom where the first and second shells are centered$/;"	m	struct:ChronusQ::BasisPair
centerP	include/basisset.h	/^  double  centerP[3][MAXCONTRACTION][MAXCONTRACTION];	\/\/ x,y,z coordinate of the combined center of the shellpair (alpha*A+beta*B)\/(alpha+beta)$/;"	m	struct:ChronusQ::ShellPair
centerPZeta	include/basisset.h	/^  double  centerPZeta[3][MAXCONTRACTION][MAXCONTRACTION];	\/\/ centerP*(alpha+beta)$/;"	m	struct:ChronusQ::ShellPair
charOffset	src/fileio/fileio.cpp	/^int FileIO::charOffset(int offset, char *offsetType) {$/;"	f	class:FileIO
charge	include/molecule.h	/^  inline int charge() {return this->charge_;}$/;"	f	class:ChronusQ::Molecule
charge_	include/molecule.h	/^  int      charge_;      \/\/ total charge$/;"	m	class:ChronusQ::Molecule
check	include/memory.h	/^  inline void check(ostream &output=cout, string *s=NULL) {$/;"	f	class:ChronusQ::Memory
cleanEigen	include/matrix.h	/^  void cleanEigen(){$/;"	f	class:ChronusQ::Matrix
cleanEigen	src/matrix/double/cleaneigen.cpp	/^void Matrix<double>::cleanEigen(){$/;"	f	class:Matrix
clearAll	include/matrix.h	/^  inline void clearAll(ostream &output=cout) { memset(data_,0,len_*sizeof(T));};$/;"	f	class:ChronusQ::Matrix
coef	include/basisset.h	/^  double  coef[MAXCONTRACTION];  \/\/ contraction coefficients$/;"	m	struct:ChronusQ::Shell
cols	include/matrix.h	/^  inline int   cols(){            return this->cols_;         }; \/\/ Return the number of cols being used in current treatment$/;"	f	class:ChronusQ::Matrix
cols_	include/matrix.h	/^  int       cols_;             \/\/ Number of columns (slowest running index) to be used by routies$/;"	m	class:ChronusQ::Matrix
cols_t_	include/matrix.h	/^  int       cols_t_;           \/\/ Number of columns (slowest running index) upon allocation (permanent)$/;"	m	class:ChronusQ::Matrix
complex_test	src/mattest/mattest_complex.cpp	/^void complex_test(int N,int M){$/;"	f
computeAOOneE	src/aointegrals/aointegrals_builders.cpp	/^void AOIntegrals::computeAOOneE(){$/;"	f	class:AOIntegrals
computeAOTwoE	src/aointegrals/aointegrals_builders.cpp	/^void AOIntegrals::computeAOTwoE(){$/;"	f	class:AOIntegrals
computeEnergy	src/singleslater/singleslater.cpp	/^void SingleSlater::computeEnergy(){$/;"	f	class:SingleSlater
computeExcitedStates	src/sdresponse/sdresponse.cpp	/^void SDResponse::computeExcitedStates(){$/;"	f	class:SDResponse
computeFmTTaylor	src/aointegrals/aointegrals.cpp	/^void AOIntegrals::computeFmTTaylor(double *FmT, double T, int maxM, int minM){$/;"	f	class:AOIntegrals
controls_	include/aointegrals.h	/^  Controls     	*controls_;$/;"	m	class:ChronusQ::AOIntegrals
controls_	include/mointegrals.h	/^  ChronusQ::Controls     	*controls_;$/;"	m	class:ChronusQ::MOIntegrals
controls_	include/sdresponse.h	/^  ChronusQ::Controls     	*controls_;$/;"	m	class:ChronusQ::SDResponse
controls_	include/singleslater.h	/^  ChronusQ::Controls     	*controls_;$/;"	m	class:ChronusQ::SingleSlater
convShell	src/basisset/basisset_libint.cpp	/^void BasisSet::convShell(Molecule* mol) {$/;"	f	class:BasisSet
convToLI	include/basisset.h	/^  bool convToLI = false;$/;"	m	class:ChronusQ::BasisSet
coulombA	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *coulombA() { return this->coulombA_;};$/;"	f	class:ChronusQ::SingleSlater
coulombA_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *coulombA_;$/;"	m	class:ChronusQ::SingleSlater
coulombB	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *coulombB() { return this->coulombB_;};$/;"	f	class:ChronusQ::SingleSlater
coulombB_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *coulombB_;$/;"	m	class:ChronusQ::SingleSlater
cpyData	src/matrix/complex/matrix_setters_complex.cpp	/^template<> void Matrix<dcomplex>::cpyData<dcomplex>(dcomplex *x){ $/;"	f	class:ChronusQ::Matrix
cpyData	src/matrix/double/matrix_setters_double.cpp	/^template<> void Matrix<double>::cpyData<double>(double *x){ $/;"	f	class:ChronusQ::Matrix
createShellPair	src/basisset/basisset.cpp	/^void BasisSet::createShellPair(Molecule *mol) {$/;"	f	class:BasisSet
dFactorial	include/global.h	/^static double dFactorial[21] = {$/;"	v
data	include/matrix.h	/^  inline T    *data(){            return this->data_;         }; \/\/ Return the internal storage array        (template)$/;"	f	class:ChronusQ::Matrix
data_	include/matrix.h	/^  T         *data_;            \/\/ Internal element storage$/;"	m	class:ChronusQ::Matrix
dcomplex	include/clapack.h	/^typedef std::complex<double> dcomplex;$/;"	t
dcomplex	include/global.h	/^typedef std::complex<double> dcomplex;$/;"	t
deltaAB	include/aointegrals.h	/^  double deltaAB[3];$/;"	m	struct:ChronusQ::PairConstants
deltaAB	include/basisset.h	/^  double  deltaAB[3];		\/\/ x,y,z distance between centers xA-xB, yA-yB, zA-zB$/;"	m	struct:ChronusQ::ShellPair
deltaPA	include/aointegrals.h	/^  double deltaPA[3][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
deltaPA	include/basisset.h	/^  double  deltaPA[3][MAXCONTRACTION][MAXCONTRACTION];	\/\/ x,y,z distance P-A$/;"	m	struct:ChronusQ::ShellPair
deltaPApPB	include/basisset.h	/^  double  deltaPApPB[3][3][MAXCONTRACTION][MAXCONTRACTION];\/\/ PAi+PBj$/;"	m	struct:ChronusQ::ShellPair
deltaPAtPB	include/basisset.h	/^  double  deltaPAtPB[3][3][MAXCONTRACTION][MAXCONTRACTION];\/\/ PAi*PBj$/;"	m	struct:ChronusQ::ShellPair
deltaPB	include/aointegrals.h	/^  double deltaPB[3][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
deltaPB	include/basisset.h	/^  double  deltaPB[3][MAXCONTRACTION][MAXCONTRACTION];	\/\/ x,y,z distance P-B$/;"	m	struct:ChronusQ::ShellPair
deltaPZ	include/aointegrals.h	/^  double deltaPZ[3][MAXCONTRACTION][MAXCONTRACTION][MAXATOMS];$/;"	m	struct:ChronusQ::PairConstants
deltaWP	include/aointegrals.h	/^  double deltaWP[3][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
deltaWQ	include/aointegrals.h	/^  double deltaWQ[3][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
densityA	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *densityA() { return this->densityA_;};$/;"	f	class:ChronusQ::SingleSlater
densityA_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *densityA_;$/;"	m	class:ChronusQ::SingleSlater
densityB	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *densityB() { return this->densityB_;};$/;"	f	class:ChronusQ::SingleSlater
densityB_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *densityB_;$/;"	m	class:ChronusQ::SingleSlater
diag	src/matrix/complex/matrix_miscmath_complex.cpp	/^template<> void Matrix<dcomplex>::diag(Matrix *B){ this->doDiag(B);};$/;"	f	class:ChronusQ::Matrix
diag	src/matrix/double/matrix_miscmath_double.cpp	/^template<> void Matrix<double>::diag(Matrix *B){ this->doDiag(B);};$/;"	f	class:ChronusQ::Matrix
directTwoE	include/controls.h	/^  bool  	directTwoE;     \/\/ if direct two-electron will performed$/;"	m	class:ChronusQ::Controls
divConst	include/basisset.h	/^  double  divConst;              \/\/ normalization constant = Shell.norm\/divConst$/;"	m	struct:ChronusQ::AOCartesian
divConst	include/basisset.h	/^  double  divConst[250];	\/\/ division constant; $/;"	m	struct:ChronusQ::ShellPair
doDiag	src/matrix/complex/matrix_miscmath_complex.cpp	/^template<> void Matrix<dcomplex>::doDiag(Matrix *B){$/;"	f	class:ChronusQ::Matrix
doDiag	src/matrix/double/matrix_miscmath_double.cpp	/^template<> void Matrix<double>::doDiag(Matrix *B){$/;"	f	class:ChronusQ::Matrix
doTNT	src/matrix/complex/matrix_overload_complex.cpp	/^void doTNT(Matrix<dcomplex> *res, const Matrix<dcomplex> *a, const Matrix<dcomplex> *x) {$/;"	f	namespace:ChronusQ
doTNT	src/matrix/double/matrix_overload_double.cpp	/^void doTNT(Matrix<double> *res, const Matrix<double> *a, const Matrix<double> *x) {$/;"	f	namespace:ChronusQ
doTTN	src/matrix/complex/matrix_overload_complex.cpp	/^void doTTN(Matrix<dcomplex> *res, const Matrix<dcomplex> *a, const Matrix<dcomplex> *x) {$/;"	f	namespace:ChronusQ
doTTN	src/matrix/double/matrix_overload_double.cpp	/^void doTTN(Matrix<double> *res, const Matrix<double> *a, const Matrix<double> *x) {$/;"	f	namespace:ChronusQ
doubleFact	src/tools/tools.cpp	/^double doubleFact(int t){$/;"	f	namespace:ChronusQ
double_test	src/mattest/mattest_double.cpp	/^void double_test(int N, int M){$/;"	f
eSort	src/matrix/double/matrix_miscop_double.cpp	/^template<> void Matrix<double>::eSort(){$/;"	f	class:ChronusQ::Matrix
eigLWORK	src/matrix/double/cleaneigen.cpp	/^int Matrix<double>::eigLWORK(int code, char UPLO){$/;"	f	class:Matrix
eigenvalue	src/matrix/complex/matrix_miscop_complex.cpp	/^dcomplex* Matrix<dcomplex>::eigenvalue(){                \/\/ Return the default eigenvalue array$/;"	f	class:ChronusQ::Matrix
eigenvalue	src/matrix/double/matrix_miscop_double.cpp	/^double* Matrix<double>::eigenvalue(){                \/\/ Return the default eigenvalue array$/;"	f	class:ChronusQ::Matrix
eigenvalue_	include/matrix.h	/^  T         *eigenvalue_;      \/\/ Detault eigenvalue storage (will point to eigenvalue_re_ for double)$/;"	m	class:ChronusQ::Matrix
eigenvalue_im	src/matrix/complex/matrix_miscop_complex.cpp	/^double* Matrix<dcomplex>::eigenvalue_im(){$/;"	f	class:ChronusQ::Matrix
eigenvalue_im	src/matrix/double/matrix_miscop_double.cpp	/^double* Matrix<double>::eigenvalue_im(){$/;"	f	class:ChronusQ::Matrix
eigenvalue_im_	include/matrix.h	/^  double    *eigenvalue_im_;   \/\/ Imag part of the eigenvalue vector$/;"	m	class:ChronusQ::Matrix
eigenvalue_re	src/matrix/complex/matrix_miscop_complex.cpp	/^double* Matrix<dcomplex>::eigenvalue_re(){$/;"	f	class:ChronusQ::Matrix
eigenvalue_re	src/matrix/double/matrix_miscop_double.cpp	/^double* Matrix<double>::eigenvalue_re(){$/;"	f	class:ChronusQ::Matrix
eigenvalue_re_	include/matrix.h	/^  double    *eigenvalue_re_;   \/\/ Real part of the eigenvalue vector$/;"	m	class:ChronusQ::Matrix
eigenvaluez	include/matrix.h	/^  inline dcomplex* eigenvaluez(){  if(this->eigenvaluez_  !=NULL) return this->eigenvaluez_;   else throw 3106;}; \/\/ Return the eigenvalues in complex format$/;"	f	class:ChronusQ::Matrix
eigenvaluez_	include/matrix.h	/^  dcomplex  *eigenvaluez_;     \/\/ Complex cast of the eigenvalue vector$/;"	m	class:ChronusQ::Matrix
eigenvector	include/matrix.h	/^  inline T *eigenvector(){ return this->eigenvector_r();};  \/\/ Return the defualt eigenvector array$/;"	f	class:ChronusQ::Matrix
eigenvector_	include/matrix.h	/^  T         *eigenvector_;     \/\/ Default eigenvector storage (will point to eigenvector_r_)$/;"	m	class:ChronusQ::Matrix
eigenvector_l	include/matrix.h	/^  inline T *eigenvector_l(){                                \/\/ Return the left eigenvector array$/;"	f	class:ChronusQ::Matrix
eigenvector_l_	include/matrix.h	/^  T         *eigenvector_l_;   \/\/ Default left eigenvector storage (will point to eigenvector_r_ for 'S' and 'H')$/;"	m	class:ChronusQ::Matrix
eigenvector_r	include/matrix.h	/^  inline T *eigenvector_r(){                                \/\/ Return the right eigenvector array$/;"	f	class:ChronusQ::Matrix
eigenvector_r_	include/matrix.h	/^  T         *eigenvector_r_;   \/\/ Default right eigenvector storage$/;"	m	class:ChronusQ::Matrix
eight	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
energyNuclei	include/molecule.h	/^  inline double energyNuclei() { return this->energyNuclei_;};$/;"	f	class:ChronusQ::Molecule
energyNuclei	include/singleslater.h	/^  double   energyNuclei;$/;"	m	class:ChronusQ::SingleSlater
energyNuclei_	include/molecule.h	/^  double   energyNuclei_;\/\/ nuclear repulsion energy$/;"	m	class:ChronusQ::Molecule
energyOneE	include/singleslater.h	/^  double   energyOneE;$/;"	m	class:ChronusQ::SingleSlater
energyOnly	include/controls.h	/^  bool  	energyOnly;     \/\/ compute energy only$/;"	m	class:ChronusQ::Controls
energyTwoE	include/singleslater.h	/^  double   energyTwoE;$/;"	m	class:ChronusQ::SingleSlater
exchangeA	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *exchangeA(){ return this->exchangeA_;};$/;"	f	class:ChronusQ::SingleSlater
exchangeA_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *exchangeA_;$/;"	m	class:ChronusQ::SingleSlater
exchangeB	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *exchangeB(){ return this->exchangeB_;};$/;"	f	class:ChronusQ::SingleSlater
exchangeB_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *exchangeB_;$/;"	m	class:ChronusQ::SingleSlater
exp	src/matrix/complex/matrix_overload_complex.cpp	/^Matrix<dcomplex>::EXP exp(const Matrix<dcomplex>& m){$/;"	f	namespace:ChronusQ
exp	src/matrix/double/matrix_overload_double.cpp	/^Matrix<double>::EXP exp(const Matrix<double>& m){$/;"	f	namespace:ChronusQ
expo	include/basisset.h	/^  double  expo[MAXCONTRACTION];  \/\/ exponents of primitive GTOs$/;"	m	struct:ChronusQ::Shell
factTLarge	src/aointegrals/aointegrals.cpp	/^static double factTLarge[21] = {$/;"	v	file:
factorial	src/tools/tools.cpp	/^double factorial(int t){$/;"	f	namespace:ChronusQ
fileio_	include/aointegrals.h	/^  FileIO       	*fileio_;$/;"	m	class:ChronusQ::AOIntegrals
fileio_	include/mointegrals.h	/^  ChronusQ::FileIO       	*fileio_;$/;"	m	class:ChronusQ::MOIntegrals
fileio_	include/sdresponse.h	/^  ChronusQ::FileIO       	*fileio_;$/;"	m	class:ChronusQ::SDResponse
fileio_	include/singleslater.h	/^  ChronusQ::FileIO       	*fileio_;$/;"	m	class:ChronusQ::SingleSlater
firstDer	include/controls.h	/^  bool  	firstDer;      	\/\/ compute the first derivative$/;"	m	class:ChronusQ::Controls
five	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
fixMem	include/matrix.h	/^  inline void fixMem(){$/;"	f	class:ChronusQ::Matrix
fockA	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *fockA()    { return this->fockA_;};$/;"	f	class:ChronusQ::SingleSlater
fockA_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *fockA_;$/;"	m	class:ChronusQ::SingleSlater
fockB	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *fockB()    { return this->fockB_;};$/;"	f	class:ChronusQ::SingleSlater
fockB_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *fockB_;$/;"	m	class:ChronusQ::SingleSlater
formCoulomb	src/singleslater/singleslater.cpp	/^void SingleSlater::formCoulomb(){$/;"	f	class:SingleSlater
formDensity	src/singleslater/singleslater.cpp	/^void SingleSlater::formDensity(){$/;"	f	class:SingleSlater
formExchange	src/singleslater/singleslater.cpp	/^void SingleSlater::formExchange(){$/;"	f	class:SingleSlater
formFock	src/singleslater/singleslater.cpp	/^void SingleSlater::formFock(){$/;"	f	class:SingleSlater
formGuess	src/singleslater/singleslater.cpp	/^void SingleSlater::formGuess() {$/;"	f	class:SingleSlater
format	include/matrix.h	/^  inline int format(){            return this->format_;       }; \/\/ Return the storage format$/;"	f	class:ChronusQ::Matrix
format_	include/matrix.h	/^  int       format_;           \/\/ Storage format                                  $/;"	m	class:ChronusQ::Matrix
four	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
gauFChkName	include/controls.h	/^  char   	gauFChkName[MAXNAMELEN];	\/\/ Gaussian formatted checkpoint filename$/;"	m	class:ChronusQ::Controls
generateFmTTable	src/aointegrals/aointegrals.cpp	/^void AOIntegrals::generateFmTTable() {$/;"	f	class:AOIntegrals
getLWORK	src/matrix/complex/matrix_miscop_complex.cpp	/^template<> int Matrix<dcomplex>::getLWORK(bool doGEP){$/;"	f	class:ChronusQ::Matrix
getLWORK	src/matrix/double/matrix_miscop_double.cpp	/^template<> int Matrix<double>::getLWORK(bool doGEP){$/;"	f	class:ChronusQ::Matrix
guess	include/controls.h	/^  int    	guess;         	\/\/ how to get the initial guess$/;"	m	class:ChronusQ::Controls
half	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
haveAOOneE	include/aointegrals.h	/^  bool		haveAOOneE;$/;"	m	class:ChronusQ::AOIntegrals
haveAOTwoE	include/aointegrals.h	/^  bool		haveAOTwoE;$/;"	m	class:ChronusQ::AOIntegrals
haveCoulomb	include/singleslater.h	/^  bool	haveCoulomb;$/;"	m	class:ChronusQ::SingleSlater
haveDensity	include/singleslater.h	/^  bool	haveDensity; $/;"	m	class:ChronusQ::SingleSlater
haveEigen_	include/matrix.h	/^  int       haveEigen_;        \/\/ Level of eigensystem storage (compounds)$/;"	m	class:ChronusQ::Matrix
haveExchange	include/singleslater.h	/^  bool	haveExchange;$/;"	m	class:ChronusQ::SingleSlater
haveMO	include/singleslater.h	/^  bool	haveMO;$/;"	m	class:ChronusQ::SingleSlater
haveMOabcd	include/mointegrals.h	/^  bool      haveMOabcd;$/;"	m	class:ChronusQ::MOIntegrals
haveMOiabc	include/mointegrals.h	/^  bool      haveMOiabc;$/;"	m	class:ChronusQ::MOIntegrals
haveMOiajb	include/mointegrals.h	/^  bool      haveMOiajb;$/;"	m	class:ChronusQ::MOIntegrals
haveMOijab	include/mointegrals.h	/^  bool      haveMOijab;$/;"	m	class:ChronusQ::MOIntegrals
haveMOijka	include/mointegrals.h	/^  bool      haveMOijka;$/;"	m	class:ChronusQ::MOIntegrals
haveMOijkl	include/mointegrals.h	/^  bool      haveMOijkl;$/;"	m	class:ChronusQ::MOIntegrals
hybridDFT	include/controls.h	/^  bool  	hybridDFT; 	\/\/ DFT is a hybrid functional$/;"	m	class:ChronusQ::Controls
iaIndex_	include/mointegrals.h	/^  int       **iaIndex_;$/;"	m	class:ChronusQ::MOIntegrals
iabc_	include/mointegrals.h	/^  ChronusQ::Matrix<double>    *iabc_;$/;"	m	class:ChronusQ::MOIntegrals
iajb	include/mointegrals.h	/^  inline double &iajb(int i, int a, int j, int b){$/;"	f	class:ChronusQ::MOIntegrals
iajb	include/mointegrals.h	/^  inline double &iajb(int ia, int jb){$/;"	f	class:ChronusQ::MOIntegrals
iajb_	include/mointegrals.h	/^  ChronusQ::Matrix<double>    *iajb_;$/;"	m	class:ChronusQ::MOIntegrals
iden	src/matrix/complex/matrixop_complex.cpp	/^Matrix* iden(const int n, const int m){$/;"	f	namespace:ChronusQ
iden	src/matrix/double/matrixop_double.cpp	/^Matrix* iden(const int n, const int m){$/;"	f
iend_	include/memory.h	/^  unsigned long long iend_,len_;$/;"	m	class:ChronusQ::Memory
ijIndex_	include/mointegrals.h	/^  int       **ijIndex_;$/;"	m	class:ChronusQ::MOIntegrals
ijab_	include/mointegrals.h	/^  ChronusQ::Matrix<double>    *ijab_;$/;"	m	class:ChronusQ::MOIntegrals
ijka_	include/mointegrals.h	/^  ChronusQ::Matrix<double>    *ijka_;$/;"	m	class:ChronusQ::MOIntegrals
ijkl_	include/mointegrals.h	/^  ChronusQ::Matrix<double>    *ijkl_;$/;"	m	class:ChronusQ::MOIntegrals
in	include/fileio.h	/^  fstream in;                    \/\/ file handler of the input file$/;"	m	class:ChronusQ::FileIO
index	include/molecule.h	/^  inline int index(int i) { return this->index_[i];};$/;"	f	class:ChronusQ::Molecule
index_	include/molecule.h	/^  int     *index_;       \/\/ index of atom in the atoms[] array$/;"	m	class:ChronusQ::Molecule
iniAOIntegrals	src/aointegrals/aointegrals.cpp	/^void AOIntegrals::iniAOIntegrals(Molecule *molecule, BasisSet *basisset, FileIO *fileio, Controls *controls){$/;"	f	class:AOIntegrals
iniBasisSet	src/basisset/basisset.cpp	/^void BasisSet::iniBasisSet(){$/;"	f	class:BasisSet
iniBlock	src/fileio/fileio.cpp	/^void FileIO::iniBlock(int blockNumber){$/;"	f	class:FileIO
iniControls	src/controls/controls.cpp	/^void Controls::iniControls(){$/;"	f	class:Controls
iniFileIO	src/fileio/fileio.cpp	/^void FileIO::iniFileIO(bool restart) {$/;"	f	class:FileIO
iniMOIntegrals	src/mointegrals/mointegrals.cpp	/^void MOIntegrals::iniMOIntegrals(   Molecule *molecule, BasisSet *basisSet, FileIO *fileio, $/;"	f	class:MOIntegrals
iniMolecularConstants	src/aointegrals/aointegrals.cpp	/^void AOIntegrals::iniMolecularConstants(){$/;"	f	class:AOIntegrals
iniMolecule	src/molecule/molecule.cpp	/^void Molecule::iniMolecule(int nAtoms, FileIO *fileio) {$/;"	f	class:Molecule
iniPairConstants	src/aointegrals/aointegrals.cpp	/^void AOIntegrals::iniPairConstants(ShellPair *ijShellPair){$/;"	f	class:AOIntegrals
iniQuartetConstants	src/aointegrals/aointegrals.cpp	/^void AOIntegrals::iniQuartetConstants(ShellPair *ijShellPair, ShellPair *klShellPair){$/;"	f	class:AOIntegrals
iniSDResponse	src/sdresponse/sdresponse.cpp	/^void SDResponse::iniSDResponse( Molecule *molecule, BasisSet *basisSet, MOIntegrals *mointegrals, $/;"	f	class:SDResponse
iniSingleSlater	src/singleslater/singleslater.cpp	/^void SingleSlater::iniSingleSlater(Molecule *molecule, BasisSet *basisset, AOIntegrals *aointegrals, FileIO *fileio, Controls *controls) {$/;"	f	class:SingleSlater
intSij	include/memory.h	/^  inline bool intSij(int op, int i, int j) {$/;"	f	class:ChronusQ::Memory
intSmall	include/aointegrals.h	/^  double intSmall;$/;"	m	struct:ChronusQ::PairConstants
inversezeta	include/basisset.h	/^  double  inversezeta[MAXCONTRACTION][MAXCONTRACTION];	\/\/ the inverse of the total of exponents 0.5\/(alpha+beta) $/;"	m	struct:ChronusQ::ShellPair
invzeta	include/basisset.h	/^  double  invzeta[MAXCONTRACTION][MAXCONTRACTION];	\/\/ the inverse of the total of exponents 0.5\/(alpha+beta) $/;"	m	struct:ChronusQ::ShellPair
io	src/fileio/fileio.cpp	/^void FileIO::io(char *op, int blockNumber, char *file, char *storage, int len, int offset, char *offsetType) {$/;"	f	class:FileIO
io	src/fileio/fileio.cpp	/^void FileIO::io(char *op, int blockNumber, char *file, double *storage, int len, int offset, char *offsetType) {$/;"	f	class:FileIO
io	src/fileio/fileio.cpp	/^void FileIO::io(char *op, int blockNumber, char *file, float *storage, int len, int offset, char *offsetType) {$/;"	f	class:FileIO
io	src/fileio/fileio.cpp	/^void FileIO::io(char *op, int blockNumber, char *file, int *storage, int len, int offset, char *offsetType) {$/;"	f	class:FileIO
io	src/fileio/fileio.cpp	/^void FileIO::io(char *op, int blockNumber, char *file, long *storage, int len, int offset, char *offsetType) {$/;"	f	class:FileIO
ioRead	src/matrix/double/matrix_io_double.cpp	/^void Matrix<double>::ioRead(FileIO *fileio,int blockNumber,char *fileName,int charOffset) {$/;"	f	class:ChronusQ::Matrix
ioRead	src/molecule/molecule.cpp	/^void Molecule::ioRead(FileIO *fileio) {$/;"	f	class:Molecule
ioWrite	src/matrix/double/matrix_io_double.cpp	/^void Matrix<double>::ioWrite(FileIO *fileio,int blockNumber,char *fileName,int charOffset) {$/;"	f	class:ChronusQ::Matrix
ioWrite	src/molecule/molecule.cpp	/^void Molecule::ioWrite(FileIO *fileio) {$/;"	f	class:Molecule
isOpen	include/fileio.h	/^  inline bool isOpen(int blockNumber) {$/;"	f	class:ChronusQ::FileIO
kCoeff	src/tools/tools.cpp	/^double kCoeff(int k, int a, int b, double pA, double pB){$/;"	f	namespace:ChronusQ
kinetic_	include/aointegrals.h	/^  Matrix<double>  *kinetic_;$/;"	m	class:ChronusQ::AOIntegrals
l	include/basisset.h	/^  int	  l[3];			 \/\/ x,y,z angular momentum$/;"	m	struct:ChronusQ::AOCartesian
len	include/matrix.h	/^  inline int    len(){            return this->len_;          }; \/\/ Return the number of elements stored for matrix$/;"	f	class:ChronusQ::Matrix
len_	include/matrix.h	/^  int       len_;              \/\/ Number of elements being stored in the matrix (length of data array)$/;"	m	class:ChronusQ::Matrix
len_	include/memory.h	/^  unsigned long long iend_,len_;$/;"	m	class:ChronusQ::Memory
lx	include/basisset.h	/^  int     lx;                    \/\/ x angular momentum$/;"	m	struct:ChronusQ::AOCartesian
ly	include/basisset.h	/^  int     ly;                    \/\/ y angular momentum$/;"	m	struct:ChronusQ::AOCartesian
lz	include/basisset.h	/^  int     lz;                    \/\/ z angular momentum$/;"	m	struct:ChronusQ::AOCartesian
main	src/chronusQ/chronusQ.cpp	/^int main(int argc,char *argv[]) {$/;"	f
main	src/mattest/mattest.cpp	/^int main(int argc,char *argv[]) {$/;"	f
mass	include/atoms.h	/^  double mass; $/;"	m	struct:ChronusQ::Atoms
massNumber	include/atoms.h	/^  int    massNumber; $/;"	m	struct:ChronusQ::Atoms
math	include/global.h	/^const Math math = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 0.5, 0.25,$/;"	v
maxL	include/basisset.h	/^  int maxL;$/;"	m	class:ChronusQ::BasisSet
maxPrim	include/basisset.h	/^  int maxPrim;$/;"	m	class:ChronusQ::BasisSet
memory_	include/memory.h	/^  double *memory_;$/;"	m	class:ChronusQ::Memory
moA	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *moA()      { return this->moA_;};$/;"	f	class:ChronusQ::SingleSlater
moA_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *moA_;$/;"	m	class:ChronusQ::SingleSlater
moB	include/singleslater.h	/^  inline ChronusQ::Matrix<double> *moB()      { return this->moB_;};$/;"	f	class:ChronusQ::SingleSlater
moB_	include/singleslater.h	/^  ChronusQ::Matrix<double>  *moB_;$/;"	m	class:ChronusQ::SingleSlater
mointegrals_	include/sdresponse.h	/^  ChronusQ::MOIntegrals   *mointegrals_;$/;"	m	class:ChronusQ::SDResponse
molecularConstants_	include/aointegrals.h	/^  MolecularConstants	*molecularConstants_;$/;"	m	class:ChronusQ::AOIntegrals
molecule_	include/aointegrals.h	/^  Molecule    	*molecule_;$/;"	m	class:ChronusQ::AOIntegrals
molecule_	include/mointegrals.h	/^  ChronusQ::Molecule    	*molecule_;$/;"	m	class:ChronusQ::MOIntegrals
molecule_	include/sdresponse.h	/^  ChronusQ::Molecule    	*molecule_;$/;"	m	class:ChronusQ::SDResponse
molecule_	include/singleslater.h	/^  ChronusQ::Molecule    	*molecule_;$/;"	m	class:ChronusQ::SingleSlater
mpiRecv	src/sdresponse/sdresponse.cpp	/^void SDResponse::mpiRecv(int fromID,int tag) {$/;"	f	class:SDResponse
mpiRecv	src/singleslater/singleslater.cpp	/^void SingleSlater::mpiRecv(int fromID,int tag) {$/;"	f	class:SingleSlater
mpiSend	src/sdresponse/sdresponse.cpp	/^void SDResponse::mpiSend(int toID,int tag) {$/;"	f	class:SDResponse
mpiSend	src/singleslater/singleslater.cpp	/^void SingleSlater::mpiSend(int toID,int tag) {$/;"	f	class:SingleSlater
myid	include/global.h	/^  int  myid;$/;"	m	struct:GlobalMPI
nAE	include/singleslater.h	/^  inline int nAE()    { return this->nAE_;};$/;"	f	class:ChronusQ::SingleSlater
nAE_	include/singleslater.h	/^  int      nAE_;$/;"	m	class:ChronusQ::SingleSlater
nAOPair	include/basisset.h	/^  int     nAOPair;		\/\/ number of unique AO pairs$/;"	m	struct:ChronusQ::ShellPair
nAOs	include/basisset.h	/^  int	  nAOs;			 \/\/ number of AOs in this shell$/;"	m	struct:ChronusQ::Shell
nAtom	include/aointegrals.h	/^  int nAtom; \/\/number of Atoms$/;"	m	struct:ChronusQ::MolecularConstants
nAtoms	include/molecule.h	/^  inline int nAtoms() {return this->nAtoms_;};$/;"	f	class:ChronusQ::Molecule
nAtoms_	include/molecule.h	/^  int      nAtoms_;      \/\/ number of atoms in the system$/;"	m	class:ChronusQ::Molecule
nBE	include/singleslater.h	/^  inline int nBE()    { return this->nBE_;};$/;"	f	class:ChronusQ::SingleSlater
nBE_	include/singleslater.h	/^  int      nBE_;$/;"	m	class:ChronusQ::SingleSlater
nBasis	include/aointegrals.h	/^  int nBasis[2];   \/\/number of Basis Function$/;"	m	struct:ChronusQ::PairConstants
nBasis	include/basisset.h	/^  inline int     nBasis()  {return this->nBasis_;};$/;"	f	class:ChronusQ::BasisSet
nBasis	include/basisset.h	/^  int     nBasis[2];		\/\/ number of basis function on each shell$/;"	m	struct:ChronusQ::ShellPair
nBasis	include/singleslater.h	/^  inline int nBasis() { return this->nBasis_;};$/;"	f	class:ChronusQ::SingleSlater
nBasis_	include/aointegrals.h	/^  int       nBasis_;$/;"	m	class:ChronusQ::AOIntegrals
nBasis_	include/basisset.h	/^  int  nBasis_;                 \/\/ number of basis functions$/;"	m	class:ChronusQ::BasisSet
nBasis_	include/sdresponse.h	/^  int       nBasis_;$/;"	m	class:ChronusQ::SDResponse
nBasis_	include/singleslater.h	/^  int      nBasis_;$/;"	m	class:ChronusQ::SingleSlater
nLShell	include/basisset.h	/^  inline int nLShell(int L){return this->nLShell_[L];};$/;"	f	class:ChronusQ::BasisSet
nLShell_	include/basisset.h	/^  int  nLShell_[20];            \/\/ number of S,P,D,F,G... shells$/;"	m	class:ChronusQ::BasisSet
nOccA	include/singleslater.h	/^  inline int nOccA()  { return this->nOccA_;};$/;"	f	class:ChronusQ::SingleSlater
nOccA_	include/singleslater.h	/^  int      nOccA_;$/;"	m	class:ChronusQ::SingleSlater
nOccB	include/singleslater.h	/^  inline int nOccB()  { return this->nOccB_;}$/;"	f	class:ChronusQ::SingleSlater
nOccB_	include/singleslater.h	/^  int      nOccB_;$/;"	m	class:ChronusQ::SingleSlater
nPGTOs	include/aointegrals.h	/^  int nPGTOs[2];   \/\/number of PGTOs$/;"	m	struct:ChronusQ::PairConstants
nPGTOs	include/basisset.h	/^  int     nPGTOs;                \/\/ level of contraction of the shell$/;"	m	struct:ChronusQ::Shell
nPGTOs	include/basisset.h	/^  int     nPGTOs[2];		\/\/ number of primitive Gaussian (degree of contract) on each shell$/;"	m	struct:ChronusQ::BasisPair
nPGTOs	include/basisset.h	/^  int     nPGTOs[2];		\/\/ number of primitive Gaussian (degree of contract) on each shell$/;"	m	struct:ChronusQ::ShellPair
nPrimitive	include/basisset.h	/^  inline int nPrimitive()  {return this->nPrimitive_;};$/;"	f	class:ChronusQ::BasisSet
nPrimitive_	include/basisset.h	/^  int  nPrimitive_;             \/\/ number of primitive GTOs$/;"	m	class:ChronusQ::BasisSet
nShell	include/basisset.h	/^  inline int     nShell()  {return this->nShell_;};$/;"	f	class:ChronusQ::BasisSet
nShellPair	include/basisset.h	/^  inline int nShellPair()  {return this->nShellPair_;};$/;"	f	class:ChronusQ::BasisSet
nShellPair_	include/basisset.h	/^  int  nShellPair_;             \/\/ number of shell pairs$/;"	m	class:ChronusQ::BasisSet
nShell_	include/basisset.h	/^  int  nShell_;                 \/\/ number of shells$/;"	m	class:ChronusQ::BasisSet
nStates_	include/sdresponse.h	/^  int       nStates_;$/;"	m	class:ChronusQ::SDResponse
nTT_	include/aointegrals.h	/^  int       nTT_;$/;"	m	class:ChronusQ::AOIntegrals
nTT_	include/singleslater.h	/^  int      nTT_;$/;"	m	class:ChronusQ::SingleSlater
nTotalE	include/molecule.h	/^  inline int nTotalE() {return this->nTotalE_;};$/;"	f	class:ChronusQ::Molecule
nTotalE_	include/molecule.h	/^  int      nTotalE_;     \/\/ total number of electrons$/;"	m	class:ChronusQ::Molecule
nVirA	include/singleslater.h	/^  inline int nVirA()  { return this->nVirB_;};$/;"	f	class:ChronusQ::SingleSlater
nVirA_	include/singleslater.h	/^  int      nVirA_;$/;"	m	class:ChronusQ::SingleSlater
nVirB	include/singleslater.h	/^  inline int nVirB()  { return this->nVirB_;};$/;"	f	class:ChronusQ::SingleSlater
nVirB_	include/singleslater.h	/^  int      nVirB_;$/;"	m	class:ChronusQ::SingleSlater
name	include/basisset.h	/^  char    name[2];               \/\/ name of the shell - "S","P","D","F","G"$/;"	m	struct:ChronusQ::Shell
name_	include/matrix.h	/^  char      name_[MAXNAMELEN]; \/\/ Name of the Matrix$/;"	m	class:ChronusQ::Matrix
name_bin	include/fileio.h	/^  char *name_bin;                \/\/ name of the binary file$/;"	m	class:ChronusQ::FileIO
name_in	include/fileio.h	/^  char *name_in;                 \/\/ name of the input file$/;"	m	class:ChronusQ::FileIO
name_out	include/fileio.h	/^  char *name_out;                \/\/ name of the output file$/;"	m	class:ChronusQ::FileIO
name_scr	include/fileio.h	/^  char *name_scr;                \/\/ name of the scratch file$/;"	m	class:ChronusQ::FileIO
nine	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
nodeNameLen	include/global.h	/^  int  nodeNameLen;$/;"	m	struct:GlobalMPI
norm	include/basisset.h	/^  double  norm[MAXCONTRACTION];  \/\/ normalization constants of primitive GTOs (divided by AOCartesian.divConst)$/;"	m	struct:ChronusQ::Shell
norm	include/basisset.h	/^  double  norm[MAXCONTRACTION][MAXCONTRACTION];		\/\/ pairwise normalization constant$/;"	m	struct:ChronusQ::ShellPair
normQuartet	include/aointegrals.h	/^  double normQuartet[MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::QuartetConstants
norm_col	src/matrix/double/matrix_miscop_double.cpp	/^template<> void Matrix<double>::norm_col(){$/;"	f	class:ChronusQ::Matrix
one	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
oneE_	include/aointegrals.h	/^  Matrix<double>  *oneE_;$/;"	m	class:ChronusQ::AOIntegrals
oneehRRSab	src/aointegrals/aointegrals_onee.cpp	/^double AOIntegrals::oneehRRSab(int LA,int *lA,int LB,int *lB) {$/;"	f	class:AOIntegrals
oneehRRTSab	src/aointegrals/aointegrals_onee.cpp	/^double AOIntegrals::oneehRRTSab(int LA,int *lA,int LB,int *lB,int *i, int *j) {$/;"	f	class:AOIntegrals
oneehRRVab	src/aointegrals/aointegrals_onee.cpp	/^double AOIntegrals::oneehRRVab(int LA,int *lA,int LB,int *lB){$/;"	f	class:AOIntegrals
oneevRRSa0	src/aointegrals/aointegrals_onee.cpp	/^double AOIntegrals::oneevRRSa0(int LA,int *lA,int *i,int *j) {$/;"	f	class:AOIntegrals
oneevRRTa0	src/aointegrals/aointegrals_onee.cpp	/^double AOIntegrals::oneevRRTa0(int LA,int *lA,int *i,int *j) {$/;"	f	class:AOIntegrals
oneevRRTab	src/aointegrals/aointegrals_onee.cpp	/^double AOIntegrals::oneevRRTab(int LA,int *lA,int LB,int *lB,int *i,int *j) {$/;"	f	class:AOIntegrals
oneevRRVa0	src/aointegrals/aointegrals_onee.cpp	/^double AOIntegrals::oneevRRVa0(int *iAtom,int m,int LA,int *lA, int *i, int *j){$/;"	f	class:AOIntegrals
openIn	include/fileio.h	/^  inline void openIn() {$/;"	f	class:ChronusQ::FileIO
operator ()	include/matrix.h	/^  inline T& operator()(int row, int col){  $/;"	f	class:ChronusQ::Matrix
operator *	src/matrix/complex/matrix_overload_complex.cpp	/^Matrix<dcomplex>::Product Matrix<dcomplex>::operator*(const Matrix &m) const{$/;"	f	class:ChronusQ::Matrix
operator *	src/matrix/double/matrix_overload_double.cpp	/^Matrix<double>::Product Matrix<double>::operator*(const Matrix &m) const{$/;"	f	class:ChronusQ::Matrix
operator +=	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator+=(const Matrix *m) {$/;"	f	class:ChronusQ::Matrix
operator +=	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator+=(const Matrix *m) {$/;"	f	class:ChronusQ::Matrix
operator -	src/matrix/complex/matrix_overload_complex.cpp	/^Matrix<dcomplex>::Diff Matrix<dcomplex>::operator-(const Matrix &m) const {$/;"	f	class:ChronusQ::Matrix
operator -	src/matrix/double/matrix_overload_double.cpp	/^Matrix<double>::Diff Matrix<double>::operator-(const Matrix &m) const {$/;"	f	class:ChronusQ::Matrix
operator -=	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator-=(const Matrix *m) {$/;"	f	class:ChronusQ::Matrix
operator -=	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator-=(const Matrix *m) {$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^template<> void Matrix<dcomplex>::operator=(const TNT& m){ doTNT(this,m.a,m.x);};$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^template<> void Matrix<dcomplex>::operator=(const TTN& m){ doTTN(this,m.a,m.x);};$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator=(const Diff& m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator=(const EXP &m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator=(const Matrix *m) {$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator=(const PWR &m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator=(const Product& m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/complex/matrix_overload_complex.cpp	/^void Matrix<dcomplex>::operator=(dcomplex *m) {$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^template<> void Matrix<double>::operator=(const TNT& m){ doTNT(this,m.a,m.x);};$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^template<> void Matrix<double>::operator=(const TTN& m){ doTTN(this,m.a,m.x);};$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator=(const Diff& m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator=(const EXP &m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator=(const Matrix *m) {$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator=(const PWR &m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator=(const Product& m){$/;"	f	class:ChronusQ::Matrix
operator =	src/matrix/double/matrix_overload_double.cpp	/^void Matrix<double>::operator=(double *m) {$/;"	f	class:ChronusQ::Matrix
operator ^	src/matrix/complex/matrix_overload_complex.cpp	/^Matrix<dcomplex>::PWR Matrix<dcomplex>::operator^(const dcomplex &x) const{$/;"	f	class:ChronusQ::Matrix
operator ^	src/matrix/double/matrix_overload_double.cpp	/^Matrix<double>::PWR Matrix<double>::operator^(const double &x) const{$/;"	f	class:ChronusQ::Matrix
optGeometry	include/controls.h	/^  bool  	optGeometry;    \/\/ optimize geometry$/;"	m	class:ChronusQ::Controls
optWaveFunction	include/controls.h	/^  bool  	optWaveFunction;\/\/ optimize wave function$/;"	m	class:ChronusQ::Controls
out	include/fileio.h	/^  fstream out;                   \/\/ file handler of the output file$/;"	m	class:ChronusQ::FileIO
overlap_	include/aointegrals.h	/^  Matrix<double>  *overlap_;$/;"	m	class:ChronusQ::AOIntegrals
pack	src/matrix/double/matrix_miscop_double.cpp	/^template<> void Matrix<double>::pack(){$/;"	f	class:ChronusQ::Matrix
pairConstants_	include/aointegrals.h	/^  PairConstants 	    *pairConstants_;$/;"	m	class:ChronusQ::AOIntegrals
phys	include/global.h	/^const Phys phys = {0.5291772083000001};$/;"	v
pi	include/global.h	/^  double pi,pi32,sqrt2pi54; \/\/pi, pi^{3\/2} sqrt(2)*pi^{5\/4}$/;"	m	struct:Math
pi32	include/global.h	/^  double pi,pi32,sqrt2pi54; \/\/pi, pi^{3\/2} sqrt(2)*pi^{5\/4}$/;"	m	struct:Math
polyCoeff	src/tools/tools.cpp	/^double polyCoeff(int l, int i){$/;"	f	namespace:ChronusQ
potential_	include/aointegrals.h	/^  Matrix<double>  *potential_;$/;"	m	class:ChronusQ::AOIntegrals
powerInt	src/tools/tools.cpp	/^double powerInt(double base, int order){$/;"	f	namespace:ChronusQ
print	src/memory/memory.cpp	/^void Memory::print(long const start, long const final, long col, ostream &output, char *s) {$/;"	f	class:Memory
printAO	src/basisset/basisset.cpp	/^void BasisSet::printAO(ostream &output){$/;"	f	class:BasisSet
printAll	src/matrix/complex/matrix_io_complex.cpp	/^void Matrix<dcomplex>::printAll(int list, ostream &output) {$/;"	f	class:ChronusQ::Matrix
printAll	src/matrix/double/matrix_io_double.cpp	/^void Matrix<double>::printAll(int list, ostream &output) {$/;"	f	class:ChronusQ::Matrix
printDim	include/matrix.h	/^  inline void printDim(ostream &output=cout) {output<<this->name_<<" is a "<<this->rows_<<"(row)x"<<this->cols_<<"(column) matrix."<<endl;};$/;"	f	class:ChronusQ::Matrix
printEnergy	src/singleslater/singleslater.cpp	/^void SingleSlater::printEnergy(){$/;"	f	class:SingleSlater
printExcitedStateEnergies	src/sdresponse/sdresponse.cpp	/^void SDResponse::printExcitedStateEnergies(){$/;"	f	class:SDResponse
printInfo	src/basisset/basisset.cpp	/^void BasisSet::printInfo(FileIO *fileio,Controls *controls) {$/;"	f	class:BasisSet
printInfo	src/molecule/molecule.cpp	/^void Molecule::printInfo(FileIO *fileio,Controls *controls) {$/;"	f	class:Molecule
printInfo	src/sdresponse/sdresponse.cpp	/^void SDResponse::printInfo() {$/;"	f	class:SDResponse
printInfo	src/singleslater/singleslater.cpp	/^void SingleSlater::printInfo() {$/;"	f	class:SingleSlater
printLevel	include/controls.h	/^  int   	printLevel;	\/\/ print level$/;"	m	class:ChronusQ::Controls
printMem	include/matrix.h	/^  inline void printMem(){$/;"	f	class:ChronusQ::Matrix
printShell	src/basisset/basisset.cpp	/^void BasisSet::printShell(ostream &output){$/;"	f	class:BasisSet
printShellPair	src/basisset/basisset.cpp	/^void BasisSet::printShellPair(ostream &output){$/;"	f	class:BasisSet
quarter	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
quartetConstants_	include/aointegrals.h	/^  QuartetConstants	    *quartetConstants_;$/;"	m	class:ChronusQ::AOIntegrals
readBasisSet	src/basisset/basisset.cpp	/^void BasisSet::readBasisSet(FileIO *fileio, Molecule *mol){$/;"	f	class:BasisSet
readBlock	src/fileio/fileio.cpp	/^void FileIO::readBlock(){$/;"	f	class:FileIO
readCharge	include/molecule.h	/^  inline void readCharge(int charge) {this->charge_=charge;};$/;"	f	class:ChronusQ::Molecule
readGuessGauFChk	src/singleslater/singleslater.cpp	/^void SingleSlater::readGuessGauFChk(char *filename) {$/;"	f	class:SingleSlater
readGuessIO	src/singleslater/singleslater.cpp	/^void SingleSlater::readGuessIO() {$/;"	f	class:SingleSlater
readInput	src/classtools/classtools.cpp	/^void readInput(FileIO *fileio, Molecule *mol, BasisSet *basis,Controls *controls) {$/;"	f	namespace:ChronusQ
readMolecule	src/molecule/molecule.cpp	/^void Molecule::readMolecule(FileIO *fileio){$/;"	f	class:Molecule
readPointer	include/fileio.h	/^  long  readPointer[2*MAXBLOCK]; \/\/ read pointers$/;"	m	class:ChronusQ::FileIO
readSpin	include/molecule.h	/^  inline void readSpin(int spin) {this->spin_=spin;};$/;"	f	class:ChronusQ::Molecule
realCmplxEig_	include/matrix.h	/^  bool      realCmplxEig_;     \/\/ Complex eigenvalues of a real matrix$/;"	m	class:ChronusQ::Matrix
release	include/memory.h	/^  inline void release() {iend_ = 0;};$/;"	f	class:ChronusQ::Memory
restart	include/controls.h	/^  bool  	restart;        \/\/ restart the calculation$/;"	m	class:ChronusQ::Controls
rows	include/matrix.h	/^  inline int   rows(){            return this->rows_;         }; \/\/ Return the number of rows being used in current treatment$/;"	f	class:ChronusQ::Matrix
rows_	include/matrix.h	/^  int       rows_;             \/\/ Number of rows (leading dimension) to be used by routines$/;"	m	class:ChronusQ::Matrix
rows_t_	include/matrix.h	/^  int       rows_t_;           \/\/ Number of rows (leading dimension) upon allocation (permanent)$/;"	m	class:ChronusQ::Matrix
rw	src/fileio/fileio.cpp	/^void FileIO::rw(char *op, int blockNumber, char *file, char *charStorage, int charLen, int offset) {$/;"	f	class:FileIO
scalarProd	src/matrix/complex/matrix_miscmath_complex.cpp	/^dcomplex Matrix<dcomplex>::scalarProd(Matrix *m) {$/;"	f	class:ChronusQ::Matrix
scalarProd	src/matrix/double/matrix_miscmath_double.cpp	/^double Matrix<double>::scalarProd(Matrix *m) {$/;"	f	class:ChronusQ::Matrix
scale	include/matrix.h	/^  inline void scale(T x){ for(int i=0;i<this->len_;i++) this->data_[i] = this->data_[i]*x;};$/;"	f	class:ChronusQ::Matrix
scaleDag	src/matrix/double/matrix_miscop_double.cpp	/^template<> void Matrix<double>::scaleDag(double x) {$/;"	f	class:ChronusQ::Matrix
scr	include/fileio.h	/^  fstream scr;                   \/\/ file handler of the scratch file$/;"	m	class:ChronusQ::FileIO
secondDer	include/controls.h	/^  bool  	secondDer; 	\/\/ compute the second derivative$/;"	m	class:ChronusQ::Controls
setDag	src/matrix/complex/matrix_setters_complex.cpp	/^template<> void Matrix<dcomplex>::setDag<dcomplex>(dcomplex *x){$/;"	f	class:ChronusQ::Matrix
setDag	src/matrix/complex/matrix_setters_complex.cpp	/^template<> void Matrix<dcomplex>::setDag<double>(double *x){$/;"	f	class:ChronusQ::Matrix
setDag	src/matrix/double/matrix_setters_double.cpp	/^template<> void Matrix<double>::setDag<double>(double *x){$/;"	f	class:ChronusQ::Matrix
setNAE	include/singleslater.h	/^  inline void setNAE(int nAE)    { this->nAE_ = nAE;};$/;"	f	class:ChronusQ::SingleSlater
setNBE	include/singleslater.h	/^  inline void setNBE(int nBE)    { this->nBE_ = nBE;};$/;"	f	class:ChronusQ::SingleSlater
setNBasis	include/singleslater.h	/^  inline void setNBasis(int nBasis) { this->nBasis_ = nBasis;};$/;"	f	class:ChronusQ::SingleSlater
setName	include/matrix.h	/^  inline             void setName(char *x){ strcpy(this->name_,x);     };       \/\/ Set the name of the matrix object$/;"	f	class:ChronusQ::Matrix
setRHF	include/singleslater.h	/^  inline void setRHF(int RHF)    { this->RHF_ = RHF;};$/;"	f	class:ChronusQ::SingleSlater
setSymm	include/matrix.h	/^  inline             void setSymm(char  x){ this->symm_ = x;};                   \/\/ Set the symmetry of the matrix object$/;"	f	class:ChronusQ::Matrix
seven	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
shIndex	include/basisset.h	/^  int     shIndex;               \/\/ index of the shell in the shells[] array to which current ao belongs$/;"	m	struct:ChronusQ::AOCartesian
shIndex	include/basisset.h	/^  int     shIndex[2];           \/\/ indices of the first and second shell in the shells[] array to which current ao belongs$/;"	m	struct:ChronusQ::ShellPair
shellPairs	include/basisset.h	/^  ShellPair   *shellPairs;     \/\/ array of shellPairs$/;"	m	class:ChronusQ::BasisSet
shells	include/basisset.h	/^  Shell       *shells;         \/\/ array of shells$/;"	m	class:ChronusQ::BasisSet
shells_libint	include/basisset.h	/^  std::vector<libint2::Shell> shells_libint;$/;"	m	class:ChronusQ::BasisSet
singleSlater_	include/mointegrals.h	/^  SingleSlater  *singleSlater_;$/;"	m	class:ChronusQ::MOIntegrals
singleSlater_	include/sdresponse.h	/^  SingleSlater  *singleSlater_;$/;"	m	class:ChronusQ::SDResponse
six	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
size	include/global.h	/^  int  size;$/;"	m	struct:GlobalMPI
size	include/matrix.h	/^  inline int   size(){            return this->size_;         }; \/\/ Return the size of the matrix object     (buggy)$/;"	f	class:ChronusQ::Matrix
size	include/molecule.h	/^  inline int size() { return this->size_;};$/;"	f	class:ChronusQ::Molecule
sizeDouble	include/fileio.h	/^  int sizeDouble() { return this->sizeDouble_;};$/;"	f	class:ChronusQ::FileIO
sizeDouble_	include/fileio.h	/^  int   sizeDouble_;             \/\/ size of a double precision float point in terms of sizeof(char)$/;"	m	class:ChronusQ::FileIO
sizeFloat	include/fileio.h	/^  int sizeFloat()  { return this->sizeFloat_;};$/;"	f	class:ChronusQ::FileIO
sizeFloat_	include/fileio.h	/^  int   sizeFloat_;              \/\/ size of a float point in terms of sizeof(char)$/;"	m	class:ChronusQ::FileIO
sizeInt	include/fileio.h	/^  int sizeInt()    { return this->sizeInt_;};$/;"	f	class:ChronusQ::FileIO
sizeInt_	include/fileio.h	/^  int   sizeInt_;                \/\/ size of an integer in terms of sizeof(char)$/;"	m	class:ChronusQ::FileIO
sizeLong	include/fileio.h	/^  int sizeLong()   { return this->sizeLong_;};$/;"	f	class:ChronusQ::FileIO
sizeLong_	include/fileio.h	/^  int   sizeLong_;               \/\/ size of a long integer in terms of sizeof(char)$/;"	m	class:ChronusQ::FileIO
size_	include/matrix.h	/^  int       size_;             \/\/ Size of the matrix object (all internal storage, buggy)$/;"	m	class:ChronusQ::Matrix
size_	include/molecule.h	/^  int      size_;        \/\/ size of the object in terms of sizeof(char)$/;"	m	class:ChronusQ::Molecule
small	include/global.h	/^  double small;$/;"	m	struct:Math
smallT	src/aointegrals/aointegrals.cpp	/^static double smallT[21]={$/;"	v	file:
sortedShells	include/basisset.h	/^  int         *sortedShells;   \/\/ index of shells sorted from the largest angular momentum to the lowest$/;"	m	class:ChronusQ::BasisSet
spin	include/molecule.h	/^  inline int spin() {return this->spin_;}$/;"	f	class:ChronusQ::Molecule
spin	include/singleslater.h	/^  inline int spin()   { return this->spin_; };$/;"	f	class:ChronusQ::SingleSlater
spin_	include/molecule.h	/^  int      spin_;        \/\/ spin multiplicity$/;"	m	class:ChronusQ::Molecule
spin_	include/singleslater.h	/^  int      spin_;$/;"	m	class:ChronusQ::SingleSlater
sqrt2	include/global.h	/^  double sqrt2;$/;"	m	struct:Math
sqrt2pi54	include/global.h	/^  double pi,pi32,sqrt2pi54; \/\/pi, pi^{3\/2} sqrt(2)*pi^{5\/4}$/;"	m	struct:Math
ssNonzero	include/aointegrals.h	/^  bool   ssNonzero[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
ssPair	include/aointegrals.h	/^  double ssPair[MAXCONTRACTION][MAXCONTRACTION];$/;"	m	struct:ChronusQ::PairConstants
ssPairTotal	include/aointegrals.h	/^  double ssPairTotal;$/;"	m	struct:ChronusQ::PairConstants
strlwr	src/tools/tools.cpp	/^void strlwr(char *a) {$/;"	f	namespace:ChronusQ
strupr	src/tools/tools.cpp	/^void strupr(char *a) {$/;"	f	namespace:ChronusQ
sub	src/matrix/complex/matrix_miscmath_complex.cpp	/^template<> void Matrix<dcomplex>::sub(const Matrix *a, const Matrix *b) {$/;"	f	class:ChronusQ::Matrix
sub	src/matrix/double/matrix_miscmath_double.cpp	/^template<> void Matrix<double>::sub(const Matrix *a, const Matrix *b) {$/;"	f	class:ChronusQ::Matrix
symbol	include/atoms.h	/^  char   symbol[5];$/;"	m	struct:ChronusQ::Atoms
symm	include/matrix.h	/^  inline char  symm(){            return this->symm_;         }; \/\/ Return the symmetry currently being used$/;"	f	class:ChronusQ::Matrix
symm_	include/matrix.h	/^  char      symm_;             \/\/ Symmetry of Matrix$/;"	m	class:ChronusQ::Matrix
tBasis	src/matrix/complex/matrixop_complex.cpp	/^Matrix* tBasis(const Matrix *C, const Matrix *X){$/;"	f	namespace:ChronusQ
tBasis	src/matrix/double/matrixop_double.cpp	/^Matrix* tBasis(const Matrix *C, const Matrix *X){$/;"	f
tagBasisSet	include/global.h	/^enum {tagMolecule,tagMatrix,tagBasisSet,tagSingleSlater,tagIntegrals,tagSDResponse};$/;"	e	enum:__anon2
tagIntegrals	include/global.h	/^enum {tagMolecule,tagMatrix,tagBasisSet,tagSingleSlater,tagIntegrals,tagSDResponse};$/;"	e	enum:__anon2
tagMatrix	include/global.h	/^enum {tagMolecule,tagMatrix,tagBasisSet,tagSingleSlater,tagIntegrals,tagSDResponse};$/;"	e	enum:__anon2
tagMolecule	include/global.h	/^enum {tagMolecule,tagMatrix,tagBasisSet,tagSingleSlater,tagIntegrals,tagSDResponse};$/;"	e	enum:__anon2
tagSDResponse	include/global.h	/^enum {tagMolecule,tagMatrix,tagBasisSet,tagSingleSlater,tagIntegrals,tagSDResponse};$/;"	e	enum:__anon2
tagSingleSlater	include/global.h	/^enum {tagMolecule,tagMatrix,tagBasisSet,tagSingleSlater,tagIntegrals,tagSDResponse};$/;"	e	enum:__anon2
ten	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
three	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
thresholdAB	include/controls.h	/^  double 	thresholdAB;$/;"	m	class:ChronusQ::Controls
thresholdS	include/controls.h	/^  double 	thresholdS;$/;"	m	class:ChronusQ::Controls
thresholdSchawrtz	include/controls.h	/^  double	thresholdSchawrtz;$/;"	m	class:ChronusQ::Controls
totalEnergy	include/singleslater.h	/^  double   totalEnergy;$/;"	m	class:ChronusQ::SingleSlater
trace	src/matrix/complex/matrix_miscmath_complex.cpp	/^dcomplex Matrix<dcomplex>::trace() {$/;"	f	class:ChronusQ::Matrix
trace	src/matrix/double/matrix_miscmath_double.cpp	/^double Matrix<double>::trace() {$/;"	f	class:ChronusQ::Matrix
traceSymm	src/classtools/classtools.cpp	/^double traceSymm(Matrix<double>* a, Matrix<double>* b) {$/;"	f	namespace:ChronusQ
transNT	src/matrix/complex/matrix_miscmath_complex.cpp	/^Matrix<dcomplex>::TNT Matrix<dcomplex>::transNT(const Matrix &X){$/;"	f	class:ChronusQ::Matrix
transNT	src/matrix/double/matrix_miscmath_double.cpp	/^Matrix<double>::TNT Matrix<double>::transNT(const Matrix &X){$/;"	f	class:ChronusQ::Matrix
transTN	src/matrix/complex/matrix_miscmath_complex.cpp	/^Matrix<dcomplex>::TTN Matrix<dcomplex>::transTN(const Matrix &X){$/;"	f	class:ChronusQ::Matrix
transTN	src/matrix/double/matrix_miscmath_double.cpp	/^Matrix<double>::TTN Matrix<double>::transTN(const Matrix &X){$/;"	f	class:ChronusQ::Matrix
trans_	include/matrix.h	/^  char      trans_;            \/\/ Transpose flag, used for LAPACK routines$/;"	m	class:ChronusQ::Matrix
transpose	include/matrix.h	/^  inline void transpose(){$/;"	f	class:ChronusQ::Matrix
transposeHard	src/matrix/complex/matrix_miscmath_complex.cpp	/^void Matrix<dcomplex>::transposeHard(){$/;"	f	class:ChronusQ::Matrix
transposeHard	src/matrix/double/matrix_miscmath_double.cpp	/^void Matrix<double>::transposeHard(){$/;"	f	class:ChronusQ::Matrix
two	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
twoEC	include/aointegrals.h	/^  inline double &twoEC(int i, int j, int k, int l){$/;"	f	class:ChronusQ::AOIntegrals
twoEC	include/aointegrals.h	/^  inline double &twoEC(int ij, int kl){$/;"	f	class:ChronusQ::AOIntegrals
twoEC_	include/aointegrals.h	/^  Matrix<double>  *twoEC_;$/;"	m	class:ChronusQ::AOIntegrals
twoEX	include/aointegrals.h	/^  inline double &twoEX(int i, int j, int k, int l){$/;"	f	class:ChronusQ::AOIntegrals
twoEX	include/aointegrals.h	/^  inline double &twoEX(int ij, int kl){$/;"	f	class:ChronusQ::AOIntegrals
twoEX_	include/aointegrals.h	/^  Matrix<double>  *twoEX_;$/;"	m	class:ChronusQ::AOIntegrals
twoeSSSS0	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoeSSSS0(int *nPGTOs, ShellPair *ijShellPair, ShellPair *klShellPair){$/;"	f	class:AOIntegrals
twoehRRa0cd	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoehRRa0cd(  int *nPGTOs, ShellPair *ijShellPair, ShellPair *klShellPair,$/;"	f	class:AOIntegrals
twoehRRabcd	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoehRRabcd(  int *nPGTOs, ShellPair *ijShellPair, ShellPair *klShellPair,$/;"	f	class:AOIntegrals
twoepp00	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoepp00( int *nPGTOs, ShellPair *ijShellPair, ShellPair *klShellPair,$/;"	f	class:AOIntegrals
twoeppp0	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoeppp0( int *nPGTOs,ShellPair *ijShellPair,ShellPair *klShellPair,$/;"	f	class:AOIntegrals
twoepppp	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoepppp(int *nPGTOs,ShellPair *ijShellPair,ShellPair *klShellPair,int LA,int *lA,int LB,int *lB,int LC,int *lC,int LD,int *lD) {$/;"	f	class:AOIntegrals
twoevRRa000	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoevRRa000(ShellPair *ijShellPair,ShellPair *klShellPair,int m,int LA,int *lA,int *i,int *j,int *k,int *l) {$/;"	f	class:AOIntegrals
twoevRRa0c0	src/aointegrals/aointegrals_twoe.cpp	/^double AOIntegrals::twoevRRa0c0(  ShellPair *ijShellPair, ShellPair *klShellPair,$/;"	f	class:AOIntegrals
unpack	src/matrix/double/matrix_miscop_double.cpp	/^template<> void Matrix<double>::unpack(){$/;"	f	class:ChronusQ::Matrix
unvectorize	include/matrix.h	/^  inline void unvectorize(){$/;"	f	class:ChronusQ::Matrix
vectorize	include/matrix.h	/^  inline void vectorize(){$/;"	f	class:ChronusQ::Matrix
vectorized_	include/matrix.h	/^  bool      vectorized_;       \/\/ Boolean as to whether or not to treat the matrix as a vector$/;"	m	class:ChronusQ::Matrix
worker	src/worker/worker.cpp	/^int worker(GlobalMPI *globalMPI) {$/;"	f
writeBlock	src/fileio/fileio.cpp	/^void FileIO::writeBlock(){$/;"	f	class:FileIO
writePointer	include/fileio.h	/^  long  writePointer[2*MAXBLOCK];\/\/ write pointers$/;"	m	class:ChronusQ::FileIO
x	include/matrix.h	/^  struct     PWR{ const Matrix *a; const T *x;};  \/\/ Struct for A^x$/;"	m	struct:ChronusQ::Matrix::PWR
x	include/matrix.h	/^  struct     TNT{ const Matrix *a; const Matrix *x;};  \/\/ Struct for XA(XT) transform$/;"	m	struct:ChronusQ::Matrix::TNT
x	include/matrix.h	/^  struct     TTN{ const Matrix *a; const Matrix *x;};  \/\/ Struct for (XT)AX transform$/;"	m	struct:ChronusQ::Matrix::TTN
zero	include/global.h	/^  double zero, one, two, three, four, five, six, seven, eight, nine, ten, half, quarter;$/;"	m	struct:Math
zeta	include/basisset.h	/^  double  zeta[MAXCONTRACTION][MAXCONTRACTION];		\/\/ the total of exponents (alpha+beta) $/;"	m	struct:ChronusQ::ShellPair
~AOIntegrals	include/aointegrals.h	/^  ~AOIntegrals(){$/;"	f	class:ChronusQ::AOIntegrals
~BasisSet	include/basisset.h	/^  ~BasisSet(){$/;"	f	class:ChronusQ::BasisSet
~Controls	include/controls.h	/^  ~Controls(){;};$/;"	f	class:ChronusQ::Controls
~FileIO	src/fileio/fileio.cpp	/^FileIO::~FileIO() {$/;"	f	class:FileIO
~MOIntegrals	include/mointegrals.h	/^  ~MOIntegrals(){$/;"	f	class:ChronusQ::MOIntegrals
~Matrix	include/matrix.h	/^  ~Matrix() {$/;"	f	class:ChronusQ::Matrix
~Memory	include/memory.h	/^  ~Memory() {delete[] memory_;};$/;"	f	class:ChronusQ::Memory
~Molecule	include/molecule.h	/^  ~Molecule(){$/;"	f	class:ChronusQ::Molecule
~SDResponse	include/sdresponse.h	/^  ~SDResponse() {;};$/;"	f	class:ChronusQ::SDResponse
~SingleSlater	include/singleslater.h	/^  ~SingleSlater() {$/;"	f	class:ChronusQ::SingleSlater

#
# The Chronus Quantum (ChronusQ) software package is high-performace 
# computational chemistry software with a strong emphasis on explicitly 
# time-dependent and post-SCF quantum mechanical methods.
# 
# Copyright (C) 2014-2015 Li Research Group (University of Washington)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# 
# Contact the Developers:
#   E-Mail: xsli@uw.edu
# 
#

#!@PYTHON_EXECUTABLE@
import os,sys
sys.path.append('@PYTHONAPI_PATH@')
import libpythonapi as chronusQ
from jobs.jobMap import *
from parse.parseInput import parseInput
from parse.parseMolecule import parseMolecule
from parse.parseQM import parseQM
from parse.parseMisc import parseMisc
import time 

class MetaData:
  def init(self):
#   SCF Info
    self.scfIters = 0 
    self.E      = 0 
    self.dipole     = []
    self.quadrupole = []
    self.octupole   = []
#   RESP Info
    self.excEne = []
    self.oscStr = []
    self.davIters = []
#   RT Info
    self.lastEnergy = 0
    self.lastDipole = []
    

def runCQ(fname):
  authorfname = '@AUTHOR_PATH@'
  header = """
     ______ __                                      ____ 
    / ____// /_   _____ ____   ____   __  __ _____ / __ \ 
   / /    / __ \ / ___// __ \ / __ \ / / / // ___// / / /
  / /___ / / / // /   / /_/ // / / // /_/ /(__  )/ /_/ / 
  \____//_/ /_//_/    \____//_/ /_/ \__,_//____/ \___\_\ 
                                                         
  """
  banner = "-------------------------------------------------------------------------------\n"

  starttime= time.strftime("%c")
  
  
  mol        = chronusQ.Molecule()
  basisSet   = chronusQ.BasisSet()
  DFbasisSet = chronusQ.BasisSet()
  controls   = chronusQ.Controls()
  aoints     = chronusQ.AOIntegrals()
  
  hf_double     = chronusQ.SingleSlater_double()
  rt_double     = chronusQ.RealTime_double()
  sdr_double    = chronusQ.SDResponse_double()
  moints_double = chronusQ.MOIntegrals_double()
  
  hf_complex     = chronusQ.SingleSlater_complex()
  rt_complex     = chronusQ.RealTime_complex()
  sdr_complex    = chronusQ.SDResponse_complex()
  moints_complex = chronusQ.MOIntegrals_complex()
  
  out        = chronusQ.FileIO(fname)
  
  workers = {
    "CQMolecule"          :mol,
    "CQBasisSet"          :basisSet,
    "CQDFBasisSet"        :DFbasisSet,
    "CQControls"          :controls,
    "CQAOIntegrals"       :aoints,
    "CQSingleSlaterDouble":hf_double,
    "CQRealTimeDouble"    :rt_double,
    "CQSDResponseDouble"  :sdr_double,
    "CQMOIntegralsDouble" :moints_double,
    "CQSingleSlaterComplex":hf_complex,
    "CQRealTimeComplex"    :rt_complex,
    "CQSDResponseComplex"  :sdr_complex,
    "CQMOIntegralsComplex" :moints_complex,
    "CQFileIO"            :out
  }
  
  
  out.write("Job Started: %s"  % starttime )
  out.write(header)
  
  authors = open(authorfname, 'r')
  out.write("Author List:\n"+banner+authors.read())
  authors.close()
  
  inputf = open(fname+".inp", 'r')
  out.write("Input File:\n"+banner+inputf.read()+banner)
  inputf.close()
  
  chronusQ.initCQ()
  controls.iniControls()
  
  secDict = parseInput(workers,fname+".inp")
  
  unittest = parseMisc(workers,secDict["MISC"])
  parseMolecule(workers,secDict["MOLECULE"])
  jobStr = parseQM(workers,secDict)
  
  out.iniH5Files()
  out.iniStdGroups()
  
  jobMeta = MetaData()
  jobMap[jobStr](workers,jobMeta)

  chronusQ.finalizeCQ()
  
  endtime= time.strftime("%c")
  out.write("Job Ended: %s"  % endtime )
  return jobMeta


if __name__ in '__main__':
  try:
      fname = sys.argv[1]
  except IndexError:
      sys.exit("Please specify the input filename")

  jobMeta = runCQ(fname)
